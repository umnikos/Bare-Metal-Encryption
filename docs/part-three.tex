% implementation (10-15 pages)
\section{Реализация}
\subsection{Реализация на ядрото}
В първите 8KB на крайният изпълним файл трябва да се намира вълшебното число 0x1BADB002 което го маркира като ядро. Веднага след него следват флагове и сума за проверка.
\begin{lstlisting}
section .multiboot
align 4
    dd MAGIC_NUMBER
    dd FLAGS
    dd CHECKSUM
\end{lstlisting}                                                                                                                                 Адресът на вълшебното число трябва да е подравнено към 4 байта и за това използваме {\tt align 4}

Входът на програмата е {\tt \_start}, като това което прави е да създаде стек, да изключи прекъсванията, да създаде GDT и IDT таблици, да включи обратно прекъсванията и да извика {\tt C} функцията {\tt kernel\_main}.
\begin{lstlisting}
section .text

global _start
extern disable_interrupts
extern enable_interrupts
extern kernel_main
extern init_gdt
extern init_idt
_start:
    mov esp, stack_top
    call disable_interrupts
    call init_gdt
    call init_idt
    call enable_interrupts
    call kernel_main
global halt
halt:
    call disable_interrupts
  .loop:
    hlt
    jmp .loop
\end{lstlisting}
Функцията {\tt halt} е заположена веднага след {\tt \_start} в случай че {\tt kernel\_main} приключи работа автоматично да се извика {\tt halt} и да спре работата на компютъра.

\subsubsection{Създаване на стек}
Стекът представлява празно парче памет с начало и край и размер. {\tt stack\_top} е началото му (защото стекът върви отгоре надолу). System V ABI\footnote{ABI (Application Binary Interface) е нещо подобно на API но от ниско ниво и специфира неща от сорта на в какъв ред се слагат аргументите на функция върху стека.} спецификацията казва че при извикване на функция стекът трябва да е подравнен към 16 байта и за това го стартираме подравнен с {\tt align 16}.
\begin{lstlisting}
section .bss
align 16
stack_bottom:
    resb 16384
stack_top:
\end{lstlisting}

\subsubsection{Изключване и включване на прекъсванията}
Изключването и включването на прекъсвания става чрез {\tt cli} и {\tt sti} инструкциите, които съм направил на функции за лесно ползване от {\tt C}.
\begin{lstlisting}
global disable_interrupts
disable_interrupts:
    cli
    ret
global enable_interrupts
enable_interrupts:
    sti
    ret
\end{lstlisting}

\subsubsection{Създаване на GDT таблица}
За да се инициализира GDT таблицата тя първо трябва да бъде създадена в паметта:
\begin{lstlisting}
section .data
gdtr:
    dw gdt_end-gdt-1
    dd gdt
gdt:
    ; null segment (0x00) (has to be empty)
    dw 0 ; limit 0-15
    dw 0 ; base 0-15
    db 0 ; base 16-23
    db 0 ; type
    db 0 ; limit 16-19 | flags
    db 0 ; base 24-31

    ; code segment (0x08)
    dw 0xFFFF
    dw 0
    db 0
    db 0x9A
    db 0xCF
    db 0

    ; data segment (0x10)
    dw 0xFFFF
    dw 0
    db 0
    db 0x92
    db 0xCF
    db 0
gdt_end:
\end{lstlisting}
Първия ред в таблицата е задължителен и е просто нули. Вторият създава сегментът за кода, който се простира върху всички 4GB от паметта. Третият създава сегментът за данните, който също се простира върху всички 4GB от паметта и се препокрива с кодът. По този начин всеки адрес в паметта може да бъде прочетен, записан и изпълнен.

Зареждането на тази таблица става с {\tt lgdt} инструкцията. След като бъде заредена сегментните регистри трябва да бъдат преинициализирани за да се активират промените.
\begin{lstlisting}
section .text
global init_gdt
init_gdt:
    lgdt [gdtr]
    jmp 0x08:.reload_cs
  .reload_cs:
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    ret
\end{lstlisting}

\subsubsection{Създаване на IDT таблица}
Създаването на IDT таблица е малко по-сложно от създаването на GDT таблица защото има много повече редове, които трябва да се попълнят. Не е проблем ако са попълнени повече редове отколкото е нужно, затова съм попълнил 256 от тях за всеки случай. Всеки ред заема 8 байта, следователно трябва да резервираме общо $8\times 256$ байта за цялата таблица:
\begin{lstlisting}
section .data
idtr:
    dw idt_end-idt-1
    dd idt

section .bss
global idt
idt:
    resb 8*256
idt_end:
\end{lstlisting}
За да се инициализира таблицата трябва само да се попълни и зареди, но попълването е леко сложно и за това го правя в {\tt C}.
\begin{lstlisting}
extern fill_idt
global init_idt
init_idt:
    call fill_idt
    lidt [idtr]
\end{lstlisting}
Ето я и самата функция:
\begin{lstlisting}[language=C]
struct idt_entry {
  u16 offset_1; // offset bits 0..15
  u16 selector; // code segment selector in GDT
  u8 zero; // full of 0s for legacy reasons
  u8 type_attr; // settings
  u16 offset_2; // offset bits 0..16
} __attribute__((packed));

extern struct idt_entry idt[];
extern void idt_handler0();
extern void idt_handler1();
extern void idt_handler2();
extern void enable_interrupts();
extern void disable_interrupts();

void fill_idt() {
  out_byte(0x20, 0x11);
  out_byte(0xA0, 0x11);

  out_byte(0x21, 0x20);
  out_byte(0xA1, 0x28);
  out_byte(0x21, 0x04);
  out_byte(0xA1, 0x02);
  out_byte(0x21, 0x01);
  out_byte(0xA1, 0x01);
  out_byte(0x21, 0);
  out_byte(0xA1, 0);

  for (u32 i=0; i<256; i++) {
    struct idt_entry ih;
    if (i >= 0x20 && i < 0x28) {
      ih.offset_1 = (u32)idt_handler1 & 0xFFFF;
      ih.offset_2 = ((u32)idt_handler1 & 0xFFFF0000) >> 16;
    } else if (i >= 0x28 && i < 0x30) {
      ih.offset_1 = (u32)idt_handler2 & 0xFFFF;
      ih.offset_2 = ((u32)idt_handler2 & 0xFFFF0000) >> 16;
    } else {
      ih.offset_1 = (u32)idt_handler0 & 0xFFFF;
      ih.offset_2 = ((u32)idt_handler0 & 0xFFFF0000) >> 16;
    }
    ih.zero = 0;
    ih.selector = 0x08;
    ih.type_attr = 0x8E;
    idt[i] = ih;
  }
}
\end{lstlisting}
Първото което прави е да пренасочи PIC (Programmable Interrupt Controller) контролерите да приемат прекъсвания между адреси 0x20 и 0x29 (защото предишните адреси са заети от прекъсванията на самия процесор). След това таблицата се пълни с три различни функции:
\begin{lstlisting}
section .text
global idt_handler0
global idt_handler1
global idt_handler2
extern crash
idt_handler0:
    push 0x87654321
    call crash
    iret
idt_handler1:
    pushad
    mov al, 0x20
    out 0x20, al
    popad
    iret
idt_handler2:
    pushad
    mov al, 0x20
    out 0xA0, al
    out 0x20, al
    popad
    iret
\end{lstlisting}
{\tt idt\_handler1} и {\tt idt\_handler2} при извикването им сигнализират на PIC контролерите че прекъсването е приключило. Без да се направи това прекъсването ще продължи вечно и процесора никога няма да получи следващо прекъсване. {\tt idt\_handler0} е за останалите прекъсвания които не очакваме и ако дойдат спира процесора.

\subsubsection{Задачите на {\tt kernel\_main}}
{\tt kernel\_main} единствено извиква {\tt virtio\_init} което търси и намира virtio-serial устройството и го инициализира и след това да извика {\tt hello\_world} което използва това virtio устройство за да изпрати ``Hello, World!''.
\begin{lstlisting}[language=C]
void kernel_main() {
  struct virtio_device virtio;
  virtio_init(&virtio);
  hello_world(&virtio);
}
\end{lstlisting}

\subsection{Реализация на virtio-serial драйвер}
% TODO

\subsection{Реализация на RSA}
%TODO

