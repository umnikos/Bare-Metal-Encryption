% implementation (10-15 pages)
% specifics
\chapter{Имплементация} % FIXME
\section{Структура на проекта}
Структурата на проекта няколкократно беше променена в процеса на разработка, като в тази документация ще бъде описан само крайната структура.

В главната директория на проекта се съдържат няколко директории. Директория {\tt docs} съдържа единствено \LaTeX{} файловете, които са нужни за компилиране на документацията, както и други материали (изображения). Всички останали директории без директория {\tt builds} са различни части от кода, които могат да бъдат компилирани в различни комбинации. Различните комбинации се намират в директория {\tt builds}. Кратко описание на всички директории (освен {\tt docs} и {\tt builds}):
\begin{itemize}
  \item {\tt kernel} - Основни функционалности, свързани с работата върху bare-metal (инициализации при стартиране на компютъра и функции от ниско ниво като пускане и спиране на прекъсванията).
  \item {\tt virtio} - Имплементация на virtio-serial сериен драйвер.
  \item {\tt serial} - Имплементация на обикновен сериен драйвер.
  \item {\tt tiny-bignum-c} - Използваната библиотека за големи (дълги) числа.
  \item {\tt encryption} - Имплементация на RSA криптиране/декриптиране.
\end{itemize}

Различното комбиниране на кода е постигнато чрез използването на различни имена за входно-изходните операции в криптирането (което ги използва) и драйверите (които ги предоставят). Различното свързване след това става като се създаде един единствен {\tt C} файл, който да имплементира едните функции чрез другите. Пример за това е даден във фигура \ref{fig:io-file-example}.
\begin{figure}[ht]
  \centering
  \caption{Свързване на {\tt serial} драйвер като изход за {\tt encryption}}
  \begin{minted}{C}
    #include "../../encryption/prelude.h"
    #include "../../serial/serial.h"

    void write_out(const char* str) {
      serial_send(str);
    }

    void read_in(char* buf, i size) {
      serial_receive(buf, (u32)size);
    }

    void flush_out() {
      return;
    }
  \end{minted}
  \label{fig:io-file-example}
\end{figure}

\section{Реализация на минимално ядро}
  \subsection{Първи задачи на ядрото}
  Първото, което трябва да направи ядрото е да създаде стек за да може кодът да бъде организиран като функции. След това се изключват прекъсванията и се създават (и зареждат) GDT и IDT таблиците. След като е създадена IDT таблицата прекъсванията могат отново да се включат. След тези стъпки може да се извика {\tt C} функцията {\tt kernel\_main}, която се дефинира в директория {\tt builds} според това какво се иска да върши приложението.

  \subsection{Създаване на стек}
  Заделянето на памет може да се постигне в {\tt C} като се създаде статичен масив, но същият ефект е постигнат във фигура \ref{fig:stack-alloc} директно чрез асемблер. За да може стекът да е съвместим с {\tt C} трябва стойността на {\tt esp} регистъра винаги да се дели на 16\cite{sysvabi}. Това най-лесно се постига като стекът започне подравнен към 16 байта и се поддържа подравнен от всички следващи функции.

  \begin{figure}[ht]
    \centering
    \caption{Заделяне на памет за стекът}
    \begin{minted}{nasm}
      section .bss
      align 16
      stack_bottom:
          resb 16384
      stack_top:
    \end{minted}
    \label{fig:stack-alloc}
  \end{figure}

  Зареждането на стека е показано във фигура \ref{fig:stack-esp}. Адресът, който се зарежда в {\tt esp} е с едно по-голям от най-високият адрес в заделената памет. Това е защото при x86 стекът започва от високите адреси и върви надолу към ниските.

  \begin{figure}[ht]
    \centering
    \caption{Зареждане на стека в {\tt esp} регистъра}
    \begin{minted}{nasm}
      mov esp, stack_top
    \end{minted}
    \label{fig:stack-esp}
  \end{figure}

  \subsection{Изключване и включване на прекъсванията}
  Това става лесно с {\tt cli} и {\tt sti} асемблер инструкциите, които правят точно това. Изведени са като функции за удобство. Фигура \ref{fig:interrupt-disable} показва кода.

  \begin{figure}[ht]
    \centering
    \caption{Включване и изключване на прекъсванията}
    \begin{minted}{nasm}
      global disable_interrupts
      disable_interrupts:
          cli
          ret

      global enable_interrupts
      enable_interrupts:
          sti
          ret
    \end{minted}
    \label{fig:interrupt-disable}
  \end{figure}

  \subsection{Създаване на GDT таблица}

  \subsection{Създаване на IDT таблица}

\section{Реализация на virtio-serial драйвер}
  \subsection{Стари и преходни Virtio устройства и драйвери}

  \subsection{Търсене на Virtio устройство по PCI}

  \subsection{Договаряне с Virtio устройство}

  \subsection{Създаване на virtqueue опашките}

  \subsection{Конфигуриране на Virtio устройство}

\section{Реализация на RSA}
  \subsection{Източник на случайност}
  За RSA е най-добре да се използва източник на истинска случайност, но не може да се разчита на всеки компютър да има такъв. Асемблерската инструкция {\tt rdrand} за генериране на истински случайни числа за пръв път се появява в x86 архитектурата през 2012 година и процесори, създадени преди тази година, няма начин да имат тази инструкция. Външен хардуер като източник на случайност също е опция, но това изисква имплементирането на още един драйвер за нещо, което не е основен приоритет на проекта.

  Но все пак трябва да се имплементира някакъв източник на случайност. За целта беше избран ``Xorshift'' - изключително лесен за имплементира алгоритъм за псевдослучайни числа. Имплементацията е показана на фигура \ref{fig:xorshift}.

  Всички алгоритми за псевдослучайни числа изискват да бъде подадено първоначално случайно число (``seed''), чрез което да бъде започнато генерирането на всички останали числа. Това число може да бъде генерирано чрез точният час, което има ефектът да генерира случайно число базирано на това точно кога е бил включен компютъра от потребителя. Но дори без достъп до точен час може да се използва този метод по начинът, показан във фигура \ref{fig:seed-generation}. % TODO - CMOS chip

  \begin{figure}[ht]
    \centering
    \caption{Имплементация на Xorshift алгоритъм за случайни числа}
    \begin{minted}{C}
      int seed;

      int rng() {
        seed ^= seed << 13;
        seed ^= seed >> 17;
        seed ^= seed << 5;
        return seed;
      }
    \end{minted}
    \label{fig:xorshift}
  \end{figure}

  \begin{figure}[ht]
    \centering
    \caption{Генериране на първоначално число за Xorshift}
    \begin{minted}{C}
      void init_rng() {
        int timestamp = get_time();
        int millis = 0; // not really milliseconds
        while (get_time() == timestamp) ++millis;
        seed = millis * timestamp;
      }
    \end{minted}
    \label{fig:seed-generation}
  \end{figure}

  \subsection{Проблеми с {\tt tiny-bignum-c}}

