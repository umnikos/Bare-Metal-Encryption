% research (8-10 pages)
\section{Проучване} \label{research}
\subsection{Начин на работа на x86 компютър}
Информацията тук е взета от книгата ``The little book about OS development''\parencite{osbook}, както и от osdev.org\parencite{oswiki}.
\subsubsection{Стъпки при стартиране}
% bios vs bootloader vs kernel
При стартирането на компютъра първата програма, която се изпълнява, е неговия фърмуер (BIOS/UEFI). Той се складира в чип вътре в компютъра и има за цел да направи проверка дали всички компоненти са в изправност и след това да прехвърли изпълнението към буутлоъдъра. Това е малка програма\footnote{По-големите буутлоъдъри са разделени на две части, като първата е малка и зарежда втората, която е по-голяма. Причината за това е историческа.}, чиято роля е да зареди ядрото на операционната система в паметта и да предаде изпълнението на него. Ядрото след това зарежда всички останали компоненти от операционната система и остава пуснато докато не бъде изключен компютъра.

\subsubsection{Режими на процесора} \label{processormodes}
Един 32-битов x86 процесор може да работи в реален режим или в защитен режим\footnote{Има и други режими но това са двата, които ни интересуват.}. Реалният режим е остатък от 16-битовата ера където имаме 16 бита за адресиране на паметта без сегментация и 20 бита със сегментация (виж \ref{segmentation}) и следователно имаме достъп само до 1MB памет. По исторически причини процесорът винаги стартира в този режим и трябва да бъде превключен в защитен режим, където имаме 32 бита за адресиране и достъп до 4GB памет (без сегментиране). GRUB bootloader-а се грижи за тази задача вместо нас.

\subsubsection{Сегментация} \label{segmentation}
В реален режим на процесора (виж \ref{processormodes}) имаме 16 битови регистри за адресиране на паметта, което ни дава достъп до 65KB памет. За да увеличим това количество се използва втори 16 битов регистър и заедно правят 20 битов адрес (не 32 битов), като сегментният регистър се умножи по 16 и се добави към адресния регистър демонстрирано в следния пример: \par
\begin{table}[ht]
  \centering
  \begin{tabular}{l r@{\hskip 3pt}l}
    Сегментен регистър: & 0010 0110 0111 1001 & \color{red}0000 \\
    Адресен регистър: & 0001 1111 1110 & 1011 \\
    \hline
    Сумарен адрес: & 0010 1000 0111 0111 & 1011 \\
  \end{tabular}
  \caption{Начин на образуване на хардуерен адрес от сегментен и адресен регистър}
  \label{segmentationexample}
\end{table}
В защитен режим понеже имаме достъп до 4GB памет нуждата за сегментиране е малка, но сегментирането още съществува.\footnote{В 32 битов режим работи по друг начин.}

% \subsubsection{Странициране}
% TODO

\subsubsection{Стек}
Стекът е място от паметта за складиране на временна информация нужна при извикването на функция и е задължителен ако искаме да можем да разделим кодът ни на функции. Стекът може да се намира където операционната система реши, като мястото му се съхранява в {\tt esp} регистъра.\footnote{{\tt esp} регистъра всъщност сочи към последната стойност на стекът и постоянно се променя. Важна роля в организирането на стекът играе и {\tt ebp} регистъра.}

\subsubsection{Нива на привилегия}
Има четири нива на привилегироване, които варират от ниво 0 (най-привилеги\-ро\-ван) до ниво 3. Това коя програма кое ниво на привилегия използва зависи от операционната система, като не е нужно всички нива да бъдат използвани.

\subsubsection{GDT (Global Descriptor Table)} \label{gdt}
Сегментите също ни позволяват да слагаме различни нива на достъп за всеки сегмент, като можем да контролираме за всяко ниво дали има достъп да чете, пише или изпълнява дадено парче от паметта. Това става чрез GDT таблицата, която на всеки ред описва сегмент и неговите права за достъп. Тази задача обаче се решава по-добре чрез странициране на паметта и заради това обикновено пълним GDT с минималният брой редове който е нужен.

\subsubsection{IDT (Interrupt Descriptor Table)} \label{idt}
IDT таблицата съдържа списъка от функции, които да се извикат при определено прекъсване. Тази таблица почти винаги е нужна, тъй като прекъсвания се генерират от външни устройства и от самия процесор.

\subsubsection{Хардуерни прекъсвания чрез PIC} \label{pic}
% what it is and why we're moving it to 0x20
PIC (programmable interrupt controller) чиповете в компютъра имат за цел да слушат за хардуерни прекъсвания и да ги подават на процесора. Те общо са два, майстор и чирак\footnote{``master'' и ``slave'' на английски.}. Всеки от тях поддържа по 8 различни прекъсвания, но едно от прекъсванията на майстора е нужно за комуникация с чирака и заради това общия брой прекъсвания които достигат до процесора е 15. Поради исторически причини тези чипове трябва да се преконфигурират преди да се използват защото по подразбиране техните номера на прекъсвания съвпадат с вътрешните прекъсвания на процесора (прекъсвания 0x00-0x1F).

\subsection{Как работи virtio}
Информацията тук е взета от официалната virtio документация, версия 1.0\parencite{virtiodocs}
\subsubsection{Общо описание на virtio интерфейсът}
virtio е създадено като оптимизация при виртуализирането на периферно устройство, тъй като хост машината вместо да симулира цялото устройството само трябва да комуникира през този интерфейс. Комуникацията се осъществява чрез множество опашки наречени virtqueues, складирани в паметта и контролирани от драйвера.

Комуникацията през един virtqueue се осъществява като драйверът алокира парче памет, което или е пълно с данни за изпращане, или е празно за да приеме данни от устройството. Адресът на парчето памет и неговата дължина се изпращат по virtqueue опашка и се подава сигнал на устройството. Когато устройството е готово с парчето памет то изпраща прекъсване и драйверът може да погледне опашката за да види кое парче памет е готово.

\subsubsection{Какво представлява един virtqueue} \label{virtqueue}
Самата virtqueue в паметта представлява два циркулярни буфера и един масив от дескриптори. Дескрипторът е структура от данни съдържаща адресът на парчето памет\footnote{Хардуерният адрес.}, неговата дължина и флагове като дали то е за писане или четене от устройството. Циркулярните буфери са за синхронизация на дескрипторите. Първият буфер е за комуникация от драйвера към устройството и в него драйверът слага индексите на всички готови дескриптори. Вторият буфер е за комуникация от устройството към драйвера и държи индексите на всички използвани дескриптори, които да се рециклират от драйверът.

Структурата е объркваща за имплементиране защото въпреки че позволява двупосочна комуникация със само един virtqueue, повечето virtio устройства използват отделни опашки за приемане и изпращане на данни. Структурата също позволява и за изпращане на няколко дескриптора едновременно със само един елемент в циркулярният буфер, но това не е задължително.

\subsubsection{Стари и преходни устройства и драйвери}
Старите устройства и драйвери следват по-стара virtio спецификация (преди версия 1.0) и в някои аспекти работят по различен начин. Преходните устройства и драйвери поддържат и старата и новата virtio спецификация.

\subsubsection{Търсене на virtio устройство}
Търсенето на virtio устройства може да стане по няколко начина. Методът който съм използвал е търсене по PCI шината. Всички virtio устройства имат номер на производител 0x1AF4 и номер на устройството между 0x1000 и 0x107F включително. Стари virtio устройства имат номер между 0x1000 и 0x103F.

\subsubsection{Конфигуриране на virtio устройство} \label{virtioinit}
След намирането на virtio устройство по PCI шината получаваме номерът на прекъсването, което това устройство предизвиква, както и неговото iobase отместване на портовете за комуникация с него през {\tt in} и {\tt out} асемблерските инструкции. Чрез тези портове се осъществява инициализацията\footnote{Освен това се използва и за съобщаване на устройството при добавяне на дескриптори в някой virtqueue}, като процедурата е описана в подробности в част 3.1.1 от официалната virtio документация\parencite{virtiodocs}. Стъпките за инициализиране на virtio устройство както са описани в нея са следните:
\begin{enumerate}
  \item Рестартираме устройството
  \item Вдигаме ACKNOWLEDGE статус бита
  \item Вдигаме DRIVER статус бита
  \item Четем битовете с функциите, които поддържа устройството и записваме само тези, които ние поддържаме
  \item Вдигаме FEATURES\_OK статус бита
  \item Четем статус битовете отново за да се уверим че FEATURES\_OK бита е вдигнат
  \item Инициализираме virtqueue опашки
  \item Вдигаме DRIVER\_OK статус бит
\end{enumerate}
Като в част 3.1.2 от същата документация ни е казано да пропуснем стъпки 5 и 6.

\subsubsection{Договаряне на функции}
Някои драйвери или устройства поддържат само част от всички възможни функции. При инициализирането на устройството драйверът получава списък\footnote{32 битово число при стари устройсва, 64 битово при нови устройства. Един бит за всяка функция} с функциите, които устройството поддържа. Драйверът след това премахва всички функции от списъка които не поддържа и изпраща редактирания списък обратно към устройството. Така и драйверът и устройството се съгласяват на всички общи за тях допълнителни функции.

При невалидна комбинация от договорени функции, договорите се провалят и драйверът трябва да сигнализира на устройството, че не може да го поддържа.

\subsection{Видове криптиране}
Криптирането е процесът на разбъркване на съобщение по такъв начин че дори всеки да го чуе, само човекът към когото е адресирано съобщението да го разбере. Това се постига чрез съществуването на тайна информация (парола), която само адресантът има и му позволява да разбере съобщението. Методите за криптиране се делят на два вида: симетрично криптиране и асиметрично криптиране. При симетричното криптиране се използва една и съща тайна информация (т.нар. ключ) за кодиране и декодиране на съобщението. При асиметричното криптиране ключът за криптиране е публичен и всеки може да криптира съобщение, но ключът за декриптиране е различен и само получателя го притежава. При комуникация през интернет обикновено се използва асиметрично криптиране, защото за да си разменят двете страни симетричен ключ трябва или да се срещнат на живо или да използват асиметричен алгоритъм като Дифи-Хелман за размяна на симетричен ключ.

\subsection{Източник на случайност}
% what random numbers are, why they're needed and what entropy sources are available
Случайните числа са числа, които нямат никаква последователност или тенденция. За да е сигурен методът ни на криптиране е нужен източник на случайни числа, защото ако някой иска да разбие криптирането ни, то може да го направят като разберат какви случайни числа сме използвали при генерирането на ключът за декриптиране и повторят същия алгоритъм.

Случайните числа се делят на два типа - псевдослучайни и наистина случайни. Псевдослучайните числа само изглеждат случайни, но са генерирани по детерминистичен (повторим) начин като числата, които ще се генерират, зависят единствено от първоначалното число. Истинските случайни числа са всички други случайни числа (напр. хвърлен зар).

Има много източници на истинска случайност около нас, но почти никакви в компютрите. Един от източниците на случайност който повечето потребителски програми за криптиране ползват е самия потребител - движенията на мишката по екрана и милисекундите между натисканията на клавиши са непрецизни по неконтролируем от потребителя начин и следователно са случайни. Друг източник на истински случайни числа са хардуерните генератори на случайни числа. Те използват физични процеси като статичен или топлинен шум като източник на случайност. Някои процесори идват с вграден хардуерен генератор на случайни числа,\footnote{Асемблерската инструкция {\tt rdrand}, която става част от Intel процесорите през 2012г. и от AMD процесорите през 2015г.} но съществуват и външни модули.

Псевдослучайни числа също работят, стига да е криптографски сигурен алгоритъмът за генерирането им и да е достатъчно случайно първоначалното число.
