% research (8-10 pages)
% nothing concrete about the implementation
\chapter{Проучване} % FIXME
\hfill
\section{Фунцкии на операционна система}
Въпреки, че заданието изисква приложението да не използва операционна система, то, като bare-metal приложение, трябва да върши някои от ролите на операционна система и за това е добра идея да бъдат разгледани без съсредоточаване в детайли.
  \subsection{Драйвери}
  Драйвер представлява програма, която се грижи за комуникацията с определено устройство и е специфична за това устройство. Целта на драйвера е да скрие всички конкретики, касаещи се за устройството (производител, версия, специфичности и други) с цел лесна замяна на хардуер с друг. В днешно време драйверите обикновено се пишат от производителя на устройството за някакъв набор от операционни системи, но всеки потребител би могъл да си напише собствен драйвер.

  Тъй като на bare-metal приложенията често им се налага да комуникират с периферни устройства, то те трябва да имплементират драйвери за тези устройства.

  \subsection{Нива на привилегия при x86} \label{rings}
  Има четири нива на привилегироване, които варират от ниво 0 (най-приви\-ле\-ги\-рован) до ниво 3. Различните операционни системи използват между 2 и 4 от тези нива (Linux използва само нива 0 и 3), но за bare-metal приложение целият код може да остане на ниво 0.

  \subsection{Многозадачност}
  В повечето операционни системи многозадачност се постига чрез процеси - всяка програма, която се изпълнява, се изпълнява в процес, и процесите се редуват кога ще се изпълняват и кога ще чакат другите процеси да свършат. В bare-metal приложение обикновено има само една или няколко задачи, които трябва да бъдат изпълнени, и следователно няма нужда от многозадачност.

  \subsection{Управление и защита на паметта}
  Под ``памет'' се има предвид RAM паметта на компютъра. Устойствата за дългосрочно съхранение на информация (напр. твърд диск) се разглеждат в точка \ref{filesystems}.

  В операционните системи всеки процес има заделено парче памет с което може да прави каквото си поиска и не може да чете или записва никъде другаде. Това се прави най-вече с цел сигурност против зловредни програми и с цел една некоретно работеща програма да не повреди цялата операционна система.

  Заделянето на памет става при стартирането на програма (статична памет) и когато направи системно извикване за да поиска още памет (динамична памет). След приключването на програмата паметта се освобождава за да се използва от други програми. Менижирането на паметта по този начин е трудно (трябва да се избягва фрагментация) и за прости bare-metal приложения е по-удачно да се опрости имплементацията като се използва най-вече статична памет.

  Защитата на паметта може да стане по два начина - сегментация и странициране. Модерните операционни системи използват странициране поради ред причини (защита на всяка страница по отделно, виртуална памет, page swapping и други).
  В bare-metal приложение поради факта, че няма да се изпълнява чужд код и поради малкия брой задачи защитата на паметта чрез странициране не е задължителна част от имплементацията. Сегментацията е задължителна (не може да се изключи), но може да се направят минимален брой сегменти с които практически да се елиминират ефектите от сегментацията.

  \subsection{Файлова система} \label{filesystems}
  Файловите системи целят да организират дългосрочната информация като файлове, които да са разпределени в директории. Всяка файлова система се състои от голям брой сложни части и рядко е добра идея да се имплементира в bare-metal приложение.

\section{Виртуализация и QEMU/KVM} \label{virtualization}
Виртуализацията е пресъздаването на физическият хардуер като виртуални машини, в които да работят отделни операционни системи или bare-metal приложения, като всяко от тях се намира в т.нар. виртуална машина. Това се получава чрез още една програма, която да бъде хипервайзор.
Хипервайзорите най-общо се делят на тип-1 и тип-2. Тип-1 хипервайзорите работят директно върху хардуера като bare-metal програма (за това също така се наричат и bare-metal хипервайзори) докато тип-2 работят върху операционна система като програма.
При тип-1 хипервайзорите може да се използват хардуерни функции за процесора за да се ускори драстично виртуализацията. QEMU (Quick EMUlator) е софтуер за виртуализация от втори тип, но заедно с KVM (Kernel Virtual Machine) се превръща в нещо средно между двете.

Тип-1 хипервайзорите водят до малки загуби на бързодействие когато приложенията най-вече извършват изчисления и четене/писане в паметта, защото тези функции не трябва да се проверяват от хипервайзора тъй като те няма как да имат ефект върху реалния свят. Загубата на скорост идва при комуникацията с външния свят (входно-изходни операции), защото тази комуникация трябва да се симулира като се симулират и устройствата с които комуникира виртуализираният софтуер. Virtio интерфейсът цели да ускори входно-изходните операции като ги превърне в писане в паметта. Това става чрез създаването на специални и опростени Virtio устройства които се управляват чрез Virtio драйвери.

\section{Писане на bare-metal приложение за x86 компютър}
  \subsection{Съществуващи bare-metal приложения за криптиране}
  % TODO

  \subsection{Архитектура на процесора (x86)}
  Архитектура на процесора е колекция от правила, които хардуерната реализация на процесора трябва да следва. Тези правила включват какви инструкции процесора може или трябва да разбира и какво трябва да правят те. Спецификацията е направена от гледна точка на изпълняващия се код, и следователно различните производители могат да имат различни имплементации с различни плюсове и минуси.

  ``x86'' е фамилия от архитектури, създадена от Intel, базирана на техния 8086 микропроцесор. Архитектурата x86 е широко разпространена, и компютрите, използваши x86, са доста стандартизирани (за разлика от ARM телефоните, при които всеки производител модифицира Android спрямо конкретният хардуер). Това прави разработката за x86 сравнително лесна, защото не трябва да се знаят голям брой детайли за конкретният хардуер върху който става разработката.

  % FIXME - CISC VS RISC

  \subsection{Стекът при x86}
  Стекът е място от паметта за складиране на временни данни от изпълняващата се функция и за подаване на параметри на функцията. Без инициализиран стек кодът не може да бъде разделен на функции и също не може да се използва езикът C за програмиране. За щастие инициализирането на стек е лесно - единствено трябва да се задели достатъчно памет и да се зареди адреса на стека в {\tt esp} регистъра.

  \subsection{Реален и защитен режим на процесора при x86} \label{processormodes}
  Всеки 32-битов x86 процесор може да работи в реален режим или в защитен режим (както и някои други режими, които могат да бъдат игнорирани). Реалният режим е остатък от 16-битовата ера, където всеки регистър за адресиране на паметта е бил с дължина 16 бита. В този режим процесорът има достъп само до 1MB памет (със сегментация, виж точка \ref{segmentation}), която може да адресира. По исторически причини всеки процесор е направен да стартира в реален режим и трябва да бъде превключен към защитен режим, където регистрите са 32-битови и могат да се адресират до 4GB памет. GRUB буутлоъдърът изпълнява тази задача вместо приложението.

  \subsection{Сегментация при x86} \label{segmentation}
  В реален режим на процесора (виж точка \ref{processormodes}) всеки регистър е 16-битов, но със само един регистър за адресиране могат да се адресират само до 64KB памет. Това бързо се оказало малко и за това са били добавени сегментните регистри. Всеки сегментен регистър е по 16 бита, като един адрес се състои от един сегментен регистър (16 бита) и един адресен регистър (16 бита) като общо правят $2^{20}$ адреси. Причината да са $2^{20}$ а не $2^{32}$ е, че сегментният регистър и адресният регистър са направени да се препокриват. Физическият адрес се изчислява като сегментният регистър се умножи по 16 и се прибави към адресния регистър. Пример за това е даден в таблица \ref{tab:segmentation-calculation}.
  \begin{table}[htpb]
    \centering
    \begin{tabular}{l r@{\hskip 3pt}l}
      Сегментен регистър: & 0010 0110 0111 1001 & \color{gray}0000 \\
      Адресен регистър: & 0001 1111 1110 & 1011 \\
      \hline
      Сумарен адрес: & 0010 1000 0111 0111 & 1011 \\
    \end{tabular}
    \caption{Пример за изчисляване на физичен адрес при използване на сегментация}
    \label{tab:segmentation-calculation}
  \end{table}

  В защитен режим процесорът може да адресира до 4GB памет с 32-битови регистри и нуждата от сегментация не съществува, но използването на сегментация все пак е задължително при x86 и за това трябва да се инициализират поне минимален брой сегменти в таблицата със сегменти (виж точка \ref{gdt}).

  % \subsection{Странициране при x86}

  \subsection{GDT (Global Descriptor Table)} \label{gdt}
  GDT е таблица намираща се в паметта, която трябва да се създаде при стартиране (без GDT таблица не могат да се използват прекъсвания) и зареди чрез {\tt LGDT} асемблерска инструкция. Таблицата инструктира процесора кои сегменти от паметта могат да се пишат, четат или изпълняват като код в четирите различни права на привилегия (виж точка \ref{rings}). Минималният брой редове в таблицата е три:
  \begin{enumerate}
    \item Нулев ред, който процесорът не гледа. Пълни се с нули.
    \item Сегмент за код, който може да се чете и изпълнява.
    \item Сегмент за данни, които могат да се четат и записват.
  \end{enumerate}
  Сегментите за код и данни могат да се направят да заемат цялата памет и да се препокриват, практически премахвайки сегментацията.

  \subsection{8259 PIC (Programmable Interrupt Controller)} \label{pic}
  PIC чиповете в компютъра слушат за хардуерни прекъсвания, идващи от периферните устройсва, и ги подават на процесора един по един. Те общо са два, майстор и чирак (``master'' и ``slave'' на английски), като всеки от тях поддържа до 8 различни прекъсвания, но едно от прекъсванията на майстор чипа (IRQ 2) е нужно за комуникация с чирака и заради това броят използваеми прекъсвания от процесора е 15. Поради исторически причини тези чипове трябва да се преконфигурират преди да се използват, защото по подразбиране номерата на прекъсванията, които изпращат към процесора, съвпадат с номерата на вътрешните прекъсвания на процесора (IRQ 0x00-0x1F).

  \subsection{IDT (Interrupt Descriptor Table)} \label{idt}
  IDT таблицата съдържа списък от функции, които да бъдат извикани при определени софтуерни и хардуерни прекъсвания. Всеки ред от таблицата съдържа адресът на функцията, която отговаря за прекъсването, и друга информация за типът на прекъсването. Таблицата е задължителна за да се поддържат прекъсвания. Подобно на GDT талблицата (виж точка \ref{gdt}), IDT таблицата се намира в паметта и се зарежда чрез {\tt LIDT} асемблерска инструкция.

  \subsection{Стъпки при стартиране на x86 компютър}
  При натискането на бутона за включване на компютъра, първият код, който се изпълнява върху процесора, е фърмуерът. Фърмуерът (BIOS/UEFI) се складира върху отделен чип на дънната платка и неговата работа е да инициализира останалия хардуер (видео карта, диск, т.н.) и да провери дали е в изправност. Ако всичко е наред то той след това зарежда първите 512 байта от диска в паметта и прехвърля изпълнението към тях. От тези 512 байта, 440 байта съдържат кода на буутлоудъра (GRUB), или по-точно, една много малка част от него, която е достатъчна единствено да намери останалата част от буутлоудъра от диска и да я зареди в паметта. След това буутлоудъра представя на потребителя меню за да избере коя операционна система иска да пусне и след това трябва да я зареди в паметта. GRUB също така се грижи процесора да бъде превключен от реален в защитен режим (виж точка \ref{processormodes}).

\section{Virtio}

Един от начините да се контролира входът и изходът на виртуална машина е всяка такава операция ({\tt in/out} асемблер инструкциите) да предизвиква прекъсване на процесора, което да препрати изпълнението към хипервайзора, чиято роля става да емулира хардуерът с който виртуализираното приложение иска да комуникира. Това драстично забавя целия процес. Друг, по-ефективен метод, е хипервайзорът да предоставя специализиран интерфейс на виртуализираното приложение, чрез който да става комуникацията. Приложението трябва да има съответните драйвери, които да могат да комуникират през този интерфейс.

Virtio е интерфейсът, който се използва при QEMU. Комуникацията най-вече се състои от писане на данни в паметта и сигнализиране на устройството кога да ги прочете, което драстично намалява броят на бавните {\tt in/out} инструкции.

  \subsection{Инициализиране и управление на Virtio устройство} \label{virtioinit}
  Първото, което трябва да направи virtio драйверът, е да намери virtio устройство, което ще управлява (като това може да стане чрез PCI). След като бъде намерено устройството може да се комуникира с него чрез {\tt in/out} асемблерските инструкции. Чрез тези инструкции става цялата инициализация, като стъпките за това са следните:
  \begin{enumerate}
    \item Virtio устройството се рестартира.
    \item Драйверът повдига {\tt ACKNOWLEDGE} статус бита на устройството, за да сигнализира на устройството, че е било забелязано.
    \item Драйверът повдига {\tt DRIVER} статус бита на устройството, за да сигнализира на устройството, че ще го управлява.
    \item Драйверът прочита списъка от допълнителни функции, които поддържа устройството, премахва тези, които той не поддържа и подава новият списък на устройството.
    \item Драйверът повдига {\tt FEATURES\_OK} статус бита на устройството. (освен при стари virtio устройства)
    \item Драйверът прочита статус битовете и се уверява, че {\tt FEATURES\_OK} битът още е вдигнат. Ако не е, инициализацията се проваля. (освен при стари virtio устройства)
    \item Драйверът инициализира virtqueue опашките за комуникация с устройството и прави други инициализации, специфични за устройството.
    \item Драйверът повдига {\tt DRIVER\_OK} статус бита за да сигнализира на устройството, че инициализацията е приключила.
  \end{enumerate}

  След инициализацията комуникацията с устройството става главно чрез virtqueue опашките. Различните типове устройства имат различен брой опашки и за различни цели. При virtio-serial минималният брой опашки е две - една за вход и една за изход. Когато драйверът запише нещо в някоя опашка то той сигнализира на устройството чрез {\tt out} инструкция, а когато устройството запише нещо в някоя от опашките сигнализира на драйвера чрез хардуерно прекъсване.

  \subsection{Същност на virtqueue опашките}
  Всяка опашка се състои от два циркулярни буфера в които се държат адресите на парчета от паметта и техните размери (``дескриптори''). В единият от буферите пише драйверът, като дава дескриптори към парчета памет в които устройството може или само да пише, или само да чете (кое от двете може да прави устройството се подава като флаг в дескрипторът). След като устройството е свършил с някой дескриптор го премества в другият циркулярен буфер за да сигнализира на драйвера, че заделеното парче памет вече може да бъде рециклирано.

  Многофункционалността на virtqueue опашките също ги прави и объркващи, защото въпреки че всяка опашка сама по себе си е способна на вход и изход, повечето устройства използват отделни опашки за вход и за изход (virtio-serial включително).

  \subsection{Стари и преходни Virtio устройства}
  Повечето Virtio драйвери са направени да поддържат по-стара версия на Virtio спецификацията и по подразбиране QEMU създава устройства от този тип. Преходните драйвери/устройства са тези, които поддържат и двете версии на спецификацията.

  Пример за разликите между старата и новата спецификация е инициализацията на virtio устройство (точка \ref{virtioinit}). При старите устройства драйверът трябва да пропусне стъпки 5 и 6.

\section{Криптиране}
  % Какво е криптиране
Криптирането е процесът на разбъркване на съобщение по такъв начин, че дори всеки да го чуе, само човекът, към когото е адресирано съобщението, да може да го разбере. В миналото това се постигало чрез прости методи (като напр. шифъра на Цезар), които разчитат на това самия алгоритъм да е таен. Модерните алгоритми за криптиране не разчитат алгоритъма да е таен, а да е тайна някакво друго парче информация, която да служи като парола.

  \subsection{Симетрично криптиране}
  При симетричното криптиране се използва една и съща тайна информация (т.нар. ключ) за кодиране и декодиране на съобщението. Двете лица трябва по някакъв начин да стигнат до съгласие какъв ще бъде тайният им ключ. Това може да се случи на живо или чрез Дифи-Хелман размяна на ключове.

    % \subsubsection{Дифи-Хелман}

  \subsection{Асиметрично криптиране}
  При асиметричното криптиране се използват различни ключове за криптиране (публичен ключ) и декриптиране (таен ключ). И двата ключа се генерират от получателя на съобщението, като публичният ключ се подава на изпращача за да може с него да бъде криптирано съобщението.

    \subsubsection{Криптиране на съобщение чрез RSA}
    RSA е алгоритъм за асиметрично криптиране публикуван през 1977 година. Описан е по-подробно в точка \ref{rsa}, но обяснено на кратко, всяко съобщение се представя като число (нека се казва $m$) което се криптира/декриптира като се повдига на различни степени (нека се казват $e$ и $d$) и след това се вземе остатък при деление с публично познато число (нека се казва $n$).

    Криптирането става чрез следната операция:
    \begin{equation}
      x = m^e \mod n
      \label{rsa-raising-to-e}
    \end{equation}
    А декриптирането с обратната операция:
    \begin{equation}
      m = x^d \mod n
      \label{rsa-raising-to-d}
    \end{equation}

    За да е валиден метода на декриптиране то трябва да важи следното уравнение:
    \begin{equation}
      m = (m^e)^d \mod n
      \label{rsa-decryption-validity}
    \end{equation}

    \subsubsection{Потвърждаване на изпращач на съобщение чрез RSA}
    В уравнение \ref{rsa-decryption-validity}, числото $(m^e)^d$ също може да се представи като $(m^d)^e$ без да се промени стойността му. Това довежда до друг начин по който RSA би могъл да се използва, и той е да се провери дали дадено съобщение е легитимно или фалшиво. Ако лицето с тайното число $d$ иска да изпрати съобщение така, че всеки да може да потвърди легитимността му, то трябва към съобщението да се добави още една част, която само собственика на числото $d$ може да е създал. Ако винаги се криптира с $d$ едно и също съобщение, то криптираното число може да се преизползва и от лица без достъп до числото $d$, за това се криптира самото съобщение (или по-точно, хешът на съобщението, за да се намали големината на частта за проверка)

