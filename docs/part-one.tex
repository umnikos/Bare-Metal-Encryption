% research (8-10 pages)
% nothing concrete about the implementation
\chapter{Проучване} % FIXME
\hfill
\section{Фунцкии на операционна система}
Въпреки, че заданието изисква приложението да не използва операционна система, то, като bare-metal приложение, трябва да върши някои от ролите на операционна система и за това е добра идея да бъдат разгледани без съсредоточаване в детайли.
  \subsection{Драйвери}
  Драйвер представлява програма, която се грижи за комуникацията с определено устройство и е специфична за това устройство. Целта на драйвера е да скрие всички конкретики, касаещи се за устройството (производител, версия, специфичности и други) с цел лесна замяна на хардуер с друг. В днешно време драйверите обикновено се пишат от производителя на устройството за някакъв набор от операционни системи, но всеки потребител би могъл да си напише собствен драйвер.

  Тъй като на bare-metal приложенията често им се налага да комуникират с периферни устройства, то те трябва да имплементират драйвери за тези устройства.

  \subsection{Многозадачност}
  В повечето операционни системи многозадачност се постига чрез процеси - всяка програма, която се изпълнява, се изпълнява в процес, и процесите се редуват кога ще се изпълняват и кога ще чакат другите процеси да свършат. В bare-metal приложение обикновено има само една или няколко задачи, които трябва да бъдат изпълнени, и следователно няма нужда от многозадачност.

  \subsection{Управление на паметта}
  Под ``памет'' се има предвид RAM паметта на компютъра. Устойствата за дългосрочно съхранение на информация (напр. твърд диск) се разглеждат в точка \ref{filesystems}.

  В операционните системи всеки процес има заделено парче памет с което може да прави каквото си поиска и не може да чете или записва никъде другаде. Това се прави най-вече с цел сигурност против зловредни програми и с цел една некоретно работеща програма да не повреди цялата операционна система. В bare-metal приложение поради факта, че няма да се изпълнява чужд код и поради малкия брой задачи това не е задължителна част от имплементацията, но е препоръчителна.

  \subsection{Файлова система} \label{filesystems}
  Файловите системи целят да организират дългосрочната информация като файлове, които да са разпределени в директории. Всяка файлова система се състои от голям брой сложни части и рядко е добра идея да се имплементира в bare-metal приложение.

\section{QEMU/KVM}
% TODO
% type 1 vs type 2
% emulation vs virtualization
% role of kvm
% role of virtio

\section{Писане на bare-metal приложение за x86 компютър}
  \subsection{Съществуващи bare-metal приложения}
  % TODO

  \subsection{Реален и защитен режим на процесора при x86} \label{processormodes}
  Всеки 32-битов x86 процесор може да работи в реален режим или в защитен режим (както и някои други режими, които могат да бъдат игнорирани). Реалният режим е остатък от 16-битовата ера, където всеки регистър за адресиране на паметта е бил с дължина 16 бита. В този режим процесорът има достъп само до 1MB памет (със сегментация, виж точка \ref{segmentation}), която може да адресира. По исторически причини всеки процесор е направен да стартира в реален режим и трябва да бъде превключен към защитен режим, където регистрите са 32-битови и могат да се адресират до 4GB памет. GRUB буутлоъдърът изпълнява тази задача вместо приложението.

  \subsection{Сегментация при x86} \label{segmentation}
  В реален режим на процесора (виж точка \ref{processormodes}) всеки регистър е 16-битов, но със само един регистър за адресиране могат да се адресират само до 64KB памет. Това бързо се оказало малко и за това са били добавени сегментните регистри. Всеки сегментен регистър е по 16 бита, като един адрес се състои от един сегментен регистър (16 бита) и един адресен регистър (16 бита) като общо правят $2^{20}$ адреси. Причината да са $2^{20}$ а не $2^{32}$ е, че сегментният регистър и адресният регистър са направени да се препокриват. Физическият адрес се изчислява като сегментният регистър се умножи по 16 и се прибави към адресния регистър. Пример за това е даден в таблица \ref{tab:segmentation-calculation}.
  \begin{table}[ht]
    \centering
    \begin{tabular}{l r@{\hskip 3pt}l}
      Сегментен регистър: & 0010 0110 0111 1001 & \color{gray}0000 \\
      Адресен регистър: & 0001 1111 1110 & 1011 \\
      \hline
      Сумарен адрес: & 0010 1000 0111 0111 & 1011 \\
    \end{tabular}
    \caption{Пример за изчисляване на физичен адрес при използване на сегментация}
    \label{tab:segmentation-calculation}
  \end{table}

  В защитен режим процесорът може да адресира до 4GB памет с 32-битови регистри и нуждата от сегментация не съществува, но използването на сегментация все пак е задължително при x86 и за това трябва да се инициализират поне минимален брой сегменти в таблицата със сегменти (виж точка \ref{gdt}).

  \subsection{Странициране при x86}
  % TODO

  \subsection{Стекът при x86}
  Стекът е място от паметта за складиране на временни данни от изпълняващата се функция и за подаване на параметри на функцията. Без инициализиран стек кодът не може да бъде разделен на функции и също не може да се използва езикът C за програмиране. За щастие инициализирането на стек е лесно.

  \subsection{GDT (Global Descriptor Table)} \label{gdt}

  \subsection{IDT (Interrupt Descriptor Table)} \label{idt}

  \subsection{PCI (Programmable Interrupt Controller)} % Как се поддържат хардуерни прекъсвания чрез PIC

  \subsection{Стъпки при стартиране на x86 компютър}
  % TODO - explain it from firmware and bootloader

\section{Virtio}

\section{Криптиране}
  \subsection{Какво е криптиране}

  \subsection{Симетрично криптиране}
    \subsubsection{Дифи-Хелман}

  \subsection{Асиметрично криптиране}
    % encryption *and* sender checking

