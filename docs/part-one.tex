% research (8-10 pages)
% nothing concrete about the implementation
\chapter{Проучване} % FIXME
\hfill
\section{Фунцкии на операционна система}
Въпреки, че заданието изисква приложението да не използва операционна система, то, като bare-metal приложение, трябва да върши някои от ролите на операционна система и за това е добра идея да бъдат разгледани без съсредоточаване в детайли.
  \subsection{Драйвери}
  Драйвер представлява програма, която се грижи за комуникацията с определено устройство и е специфична за това устройство. Целта на драйвера е да скрие всички конкретики, касаещи се за устройството (производител, версия, специфичности и други) с цел лесна замяна на хардуер с друг. В днешно време драйверите обикновено се пишат от производителя на устройството за някакъв набор от операционни системи, но всеки потребител би могъл да си напише собствен драйвер.

  Тъй като на bare-metal приложенията често им се налага да комуникират с периферни устройства, то те трябва да имплементират драйвери за тези устройства.

  \subsection{Нива на привилегия при x86} \label{rings}
  Има четири нива на привилегироване, които варират от ниво 0 (най-привилегирован) до ниво 3. Различните операционни системи използват между 2 и 4 от тези нива (Linux използва само нива 0 и 3), но за bare-metal приложение целият код може да остане на ниво 0.

  \subsection{Многозадачност}
  В повечето операционни системи многозадачност се постига чрез процеси - всяка програма, която се изпълнява, се изпълнява в процес, и процесите се редуват кога ще се изпълняват и кога ще чакат другите процеси да свършат. В bare-metal приложение обикновено има само една или няколко задачи, които трябва да бъдат изпълнени, и следователно няма нужда от многозадачност.

  \subsection{Управление и защита на паметта}
  Под ``памет'' се има предвид RAM паметта на компютъра. Устойствата за дългосрочно съхранение на информация (напр. твърд диск) се разглеждат в точка \ref{filesystems}.

  В операционните системи всеки процес има заделено парче памет с което може да прави каквото си поиска и не може да чете или записва никъде другаде. Това се прави най-вече с цел сигурност против зловредни програми и с цел една некоретно работеща програма да не повреди цялата операционна система.

  Заделянето на памет става при стартирането на програма (статична памет) и когато направи системно извикване за да поиска още памет (динамична памет). След приключването на програмата паметта се освобождава за да се използва от други програми. Менижирането на паметта по този начин е трудно (трябва да се избягва фрагментация) и за прости bare-metal приложения е по-удачно да се опрости имплементацията като се използва най-вече статична памет.

  Защитата на паметта може да стане по два начина - сегментация и странициране. Двата метода са обяснени по-подробно в точки \ref{segmentation} и \ref{paging}. Модерните операционни системи използват странициране поради ред причини (защита на всяка страница по отделно, виртуална памет, page swapping и други).
  В bare-metal приложение поради факта, че няма да се изпълнява чужд код и поради малкия брой задачи защитата на паметта не е задължителна част от имплементацията.

  \subsection{Файлова система} \label{filesystems}
  Файловите системи целят да организират дългосрочната информация като файлове, които да са разпределени в директории. Всяка файлова система се състои от голям брой сложни части и рядко е добра идея да се имплементира в bare-metal приложение.

\section{QEMU/KVM}
% TODO
% type 1 vs type 2
% emulation vs virtualization
% role of kvm
% role of virtio

\section{Писане на bare-metal приложение за x86 компютър}
  \subsection{Съществуващи bare-metal приложения}
  % TODO

  \subsection{Архитектура на процесора (x86)}
  % TODO

  \subsection{Стекът при x86}
  Стекът е място от паметта за складиране на временни данни от изпълняващата се функция и за подаване на параметри на функцията. Без инициализиран стек кодът не може да бъде разделен на функции и също не може да се използва езикът C за програмиране. За щастие инициализирането на стек е лесно.

  \subsection{Реален и защитен режим на процесора при x86} \label{processormodes}
  Всеки 32-битов x86 процесор може да работи в реален режим или в защитен режим (както и някои други режими, които могат да бъдат игнорирани). Реалният режим е остатък от 16-битовата ера, където всеки регистър за адресиране на паметта е бил с дължина 16 бита. В този режим процесорът има достъп само до 1MB памет (със сегментация, виж точка \ref{segmentation}), която може да адресира. По исторически причини всеки процесор е направен да стартира в реален режим и трябва да бъде превключен към защитен режим, където регистрите са 32-битови и могат да се адресират до 4GB памет. GRUB буутлоъдърът изпълнява тази задача вместо приложението.

  \subsection{Сегментация при x86} \label{segmentation}
  В реален режим на процесора (виж точка \ref{processormodes}) всеки регистър е 16-битов, но със само един регистър за адресиране могат да се адресират само до 64KB памет. Това бързо се оказало малко и за това са били добавени сегментните регистри. Всеки сегментен регистър е по 16 бита, като един адрес се състои от един сегментен регистър (16 бита) и един адресен регистър (16 бита) като общо правят $2^{20}$ адреси. Причината да са $2^{20}$ а не $2^{32}$ е, че сегментният регистър и адресният регистър са направени да се препокриват. Физическият адрес се изчислява като сегментният регистър се умножи по 16 и се прибави към адресния регистър. Пример за това е даден в таблица \ref{tab:segmentation-calculation}.
  \begin{table}[ht]
    \centering
    \begin{tabular}{l r@{\hskip 3pt}l}
      Сегментен регистър: & 0010 0110 0111 1001 & \color{gray}0000 \\
      Адресен регистър: & 0001 1111 1110 & 1011 \\
      \hline
      Сумарен адрес: & 0010 1000 0111 0111 & 1011 \\
    \end{tabular}
    \caption{Пример за изчисляване на физичен адрес при използване на сегментация}
    \label{tab:segmentation-calculation}
  \end{table}

  В защитен режим процесорът може да адресира до 4GB памет с 32-битови регистри и нуждата от сегментация не съществува, но използването на сегментация все пак е задължително при x86 и за това трябва да се инициализират поне минимален брой сегменти в таблицата със сегменти (виж точка \ref{gdt}).

  \subsection{GDT (Global Descriptor Table)} \label{gdt}
  GDT е таблица намираща се в паметта, която трябва да се създаде при стартиране (без GDT таблица не могат да се използват прекъсвания) и зареди чрез {\tt LGDT} асемблерска инструкция. Таблицата инструктира процесора кои сегменти от паметта могат да се пишат, четат или изпълняват като код в четирите различни права на привилегия (виж точка \ref{rings}). Минималният брой редове в таблицата е три:
  \begin{enumerate}
    \item Нулев ред, който процесорът не гледа. Пълни се с нули.
    \item Сегмент за код, който може да се чете и изпълнява.
    \item Сегмент за данни, които могат да се четат и записват.
  \end{enumerate}
  Сегментите за код и данни могат да се направят да заемат цялата памет и да се препокриват, практически премахвайки сегментацията.

  \subsection{Странициране при x86} \label{paging}
  % TODO

  \subsection{8259 PIC (Programmable Interrupt Controller)} \label{pic}
  PIC чиповете в компютъра слушат за хардуерни прекъсвания, идващи от периферните устройсва, и ги подават на процесора един по един. Те общо са два, майстор и чирак (``master'' и ``slave'' на английски), като всеки от тях поддържа до 8 различни прекъсвания, но едно от прекъсванията на майстор чипа (IRQ 2) е нужно за комуникация с чирака и заради това броят използваеми прекъсвания от процесора е 15. Поради исторически причини тези чипове трябва да се преконфигурират преди да се използват, защото по подразбиране номерата на прекъсванията, които изпращат към процесора, съвпадат с номерата на вътрешните прекъсвания на процесора (IRQ 0x00-0x1F).

  \subsection{IDT (Interrupt Descriptor Table)} \label{idt}
  IDT таблицата съдържа списък от функции, които да бъдат извикани при определени софтуерни и хардуерни прекъсвания. Всеки ред от таблицата съдържа адресът на функцията, която отговаря за прекъсването, и друга информация за типът на прекъсването. Таблицата е задължителна за да се поддържат прекъсвания. Подобно на GDT талблицата (виж точка \ref{gdt}), IDT таблицата се намира в паметта и се зарежда чрез {\tt LIDT} асемблерска инструкция.

  \subsection{Стъпки при стартиране на x86 компютър}
  % TODO - explain it from firmware and bootloader

\section{Virtio}

\section{Криптиране}
  \subsection{Какво е криптиране}

  \subsection{Симетрично криптиране}
    \subsubsection{Дифи-Хелман}

  \subsection{Асиметрично криптиране}
    % encryption *and* sender checking

