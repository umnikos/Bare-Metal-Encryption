% research (8-10 pages)
\section{Проучване} \label{research}
\subsection{Начин на работа на x86 компютър}
\subsubsection{Стъпки при стартиране}
% bios vs bootloader vs kernel
При стартирането на компютъра първата програма, която се изпълнява, е неговия фърмуер (BIOS/UEFI). Той се складира в чип вътре в компютъра и има за цел да направи проверка дали всички компоненти са в изправност и след това да прехвърли изпълнението към буутлоъдъра. Това е малка програма\footnote{По-големите буутлоъдъри са разделени на две части, като първата е малка и зарежда втората, която е по-голяма. Причината за това е историческа.}, чиято роля е да зареди ядрото на операционната система в паметта и да предаде изпълнението на него. Ядрото след това зарежда всички останали компоненти от операционната система и остава пуснато докато не бъде изключен компютъра.

\subsubsection{Режими на процесора} \label{processormodes}
Един 32-битов x86 процесор може да работи в реален режим или в защитен режим\footnote{Има и други режими но това са двата, които ни интересуват.}. Реалният режим е остатък от 16-битовата ера където имаме 16 бита за адресиране на паметта без сегментация и 20 бита със сегментация (виж \ref{segmentation}) и следователно имаме достъп само до 1MB памет. По исторически причини процесорът винаги стартира в този режим и трябва да бъде превключен в защитен режим, където имаме 32 бита за адресиране и достъп до 4GB памет (без сегментиране). GRUB bootloader-а се грижи за тази задача вместо нас.

\subsubsection{Сегментация} \label{segmentation}
В реален режим на процесора (виж \ref{processormodes}) имаме 16 битови регистри за адресиране на паметта, което ни дава достъп до 65KB памет. За да увеличим това количество се използва втори 16 битов регистър и заедно правят 20 битов адрес (не 32 битов), като сегментният регистър се умножи по 16 и се добави към адресния регистър демонстрирано в следния пример: \par
\begin{table}[ht]
  \centering
  \begin{tabular}{l r@{\hskip 3pt}l}
    Сегментен регистър: & 0010 0110 0111 1001 & \color{red}0000 \\
    Адресен регистър: & 0001 1111 1110 & 1011 \\
    \hline
    Сумарен адрес: & 0010 1000 0111 0111 & 1011 \\
  \end{tabular}
  \caption{Начин на образуване на хардуерен адрес от сегментен и адресен регистър}
  \label{segmentationexample}
\end{table}
В защитен режим понеже имаме достъп до 4GB памет нуждата за сегментиране е малка, но сегментирането още съществува.\footnote{В 32 битов режим работи по друг начин.}

\subsubsection{Стек}
Стекът е място от паметта за складиране на временна информация нужна при извикването на функция и е задължителен ако искаме да можем да разделим кодът ни на функции. Стекът може да се намира където операционната система реши, като мястото му се съхранява в {\tt esp} регистъра.\footnote{{\tt esp} регистъра всъщност сочи към последната стойност на стекът и постоянно се променя. Важна роля в организирането на стекът играе и {\tt ebp} регистъра.}

\subsubsection{Нива на привилегия}
Има четири нива на привилегироване, които варират от ниво 0 (най-привилегирован) до ниво 3. Това коя програма кое ниво на привилегия използва зависи от операционната система, като не е нужно всички нива да бъдат използвани.

\subsubsection{GDT (Global Descriptor Table)} \label{gdt}
Сегментите също ни позволяват да слагаме различни нива на достъп за всеки сегмент, като можем да контролираме за всяко ниво дали има достъп да чете, пише или изпълнява дадено парче от паметта. Това става чрез GDT таблицата, която на всеки ред описва сегмент и неговите права за достъп. Тази задача обаче се решава по-добре чрез странициране на паметта и заради това обикновено пълним GDT с минималният брой редове който е нужен.

\subsubsection{IDT (Interrupt Descriptor Table)} \label{idt}
IDT таблицата съдържа списъка от функции, които да се извикат при определено прекъсване. Тази таблица почти винаги е нужна, тъй като прекъсвания се генерират от външни устройства и от самия процесор.

\subsection{Как работи Virtio}
\subsubsection{Общо описание на Virtio интерфейсът}
% TODO
\subsubsection{Какво представлява virtqueue}
% TODO

\subsection{Видове криптиране}
Криптирането е процесът на разбъркване на съобщение по такъв начин че дори всеки да го чуе, само човекът към когото е адресирано съобщението да го разбере. Това се постига чрез съществуването на тайна информация която само адресантът има и му позволява да разбере съобщението. Методите за криптиране се делят на два вида: симетрично криптиране и асиметрично криптиране. При симетричното криптиране се използва една и съща тайна информация (т.нар. ключ) за кодиране и декодиране на съобщението. При асиметричното криптиране ключът за криптиране е публичен и всеки може да криптира съобщение, но ключът за декриптиране е различен и само получателя го притежава. При комуникация през интернет обикновено се използва асиметрично криптиране, защото за да си разменят двете страни симетричен ключ трябва или да се срещнат на живо или да използват асиметричен алгоритъм като Дифи-Хелман за размяна на симетричен ключ.
