\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc} % specify there may be unicode in .latex file
\usepackage[bulgarian]{babel} % support for cyrillic
%\usepackage{lmodern} % different cyrillic glyphs
\usepackage{indentfirst} % indent the first line of paragraph
\usepackage{nameref} % named references to sections
\usepackage{graphicx} % for including graphics (images)
\usepackage{geometry} % for changing page dimensions and header space
\usepackage{sectsty} % for changing font size only for sections
\usepackage[backend=bibtex,sorting=none]{biblatex} % for bibliography and citations
%\usepackage{listings} % for inserting code
%\usepackage{color} % color for code
\usepackage{xcolor} % for colored text
\usepackage{chngcntr} % to make table numbers include section numbers

% make table numbers depend on section number
\counterwithin{table}{section}
%\counterwithin{table}{subsection}
%\counterwithin{table}{subsubsection}

\addbibresource{refs} % specify file with references

% shrink page margins
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.5in}
\addtolength{\textheight}{1.75in}

% \section-specific styling
\sectionfont{\fontsize{22}{24}\selectfont}
\subsectionfont{\fontsize{20}{22}\selectfont}
\subsubsectionfont{\fontsize{18}{20}\selectfont}

\begin{document}

\fontsize{14pt}{20}\selectfont % change font to 14pt


% title page
\thispagestyle{empty} % hide line numbers for this page only
\begin{center}
  \textbf{
    ТЕХНОЛОГИЧНО УЧИЛИЩЕ ЕЛЕКТРОННИ СИСТЕМИ \\
    към ТЕХНИЧЕСКИ УНИВЕРСИТЕТ - СОФИЯ \\
  }

  \vspace{70mm}
  \textbf{\huge ДИПЛОМНА РАБОТА \\ }

  \vspace{20mm}
  {\Large Тема:
    Bare-metal application за x86 архитектура \\
    работещо върху QEMU/KVM hypervisor
  }

  \vspace{35mm}
  \begin{tabular}{p{8cm}p{8cm}}
    \centering
    Дипломант: \\
    Алекс Стефанов
    &
    \centering
    Научен ръководител: \\
    Стоил Стоилов
  \end{tabular}

  \vfill
  СОФИЯ \\
  \hfill \\
  2 0 2 1 \\
\end{center}
\newpage

% blank page
\thispagestyle{empty}
\hfill
\newpage

% introduction (1-2 pages)
\newpage
\section*{Въведение}
\addcontentsline{toc}{section}{Въведение}

% research (8-10 pages)
\newpage
\section{Проучване}
%Преди започване на писането на код проучването се състоеше от четене на книгата "The little book about OS development"\parencite{osbook}, което ми предостави обща представа за това как работи един компютър на ниско ниво и кои части от операционната система ще трябва да създам за да мога да направя приложната част от продукта. След това най-полезният ресурс беше "OSDev.org"\parencite{oswiki}, уики за всичко свързано с писането на операционни системи, което предоставя всички нужни детайли за да напиша кода в действителност. Но при създаването на virtio-serial драйвера гледах и официалната документация на virtio\parencite{virtiodocs} и един блог пост обясняващ вече написан virtio мрежови драйвер\parencite{virtioblogpost}.
\subsection{Начин на работа на x86 компютър}
\subsubsection{Стъпки при стартиране}
% bios vs bootloader vs kernel
При стартирането на компютъра първата програма която се изпълнява е фърмуера му (BIOS/UEFI). Програмата се намира в чип на дъното на машината и има за цел да направи проверка дали всички компоненти работят изправно и след това да прехвърли изпълнението към буутлоъдъра. Това е малка програма чиято роля е да зареди ядрото на операционната система в паметта и да предаде изпълнението на него. Буутлоъдъра използван в този проект е GRUB.

\subsubsection{Режими на процесора} \label{processormodes}
Един 32-битов x86 процесор може да работи в реален режим или в защитен режим. Реалният режим е остатък от 16-битовата ера където имаме 16 бита за адресиране на паметта без сегментация и 20 бита със сегментация (виж \ref{segmentation}) и следователно имаме достъп само до 1MB памет. По исторически причини процесорът винаги стартира в този режим и трябва да бъде превключен в защитен режим, където имаме 32 бита за адресиране и достъп до 4GB памет (без сегментиране). GRUB bootloader-а се грижи за тази задача вместо нас.

\subsubsection{Сегментация} \label{segmentation}
В реален режим на процесора (виж \ref{processormodes}) имаме 16 битови регистри за адресиране на паметта, което ни дава достъп до 65KB памет. За да увеличим това количество се използва и втори 16 битов регистър и заедно правят 20 битов адрес (не 32 битов), като сегментният регистър се умножи по 16 и се добави към адресния регистър демонстрирано в следния пример: \par
\begin{table}[ht]
  \centering
  \begin{tabular}{l r@{\hskip 3pt}l}
    Сегментен регистър: & 0010 0110 0111 1001 & \color{red}0000 \\
    Адресен регистър: & 0001 1111 1110 & 1011 \\
    \hline
    Сумарен адрес: & 0010 1000 0111 0111 & 1011 \\
  \end{tabular}
  \caption{Начин на образуване на хардуерен адрес от сегментен и адресен регистър}
  \label{segmentationexample}
\end{table}
В защитен режим понеже имаме достъп до 4GB памет нуждата за сегментиране е малка, но сегментирането още съществува.

\subsubsection{Стек}
Стекът е място от паметта за складиране на временна информация нужна при извикването на функция и е задължителен ако искаме да можем да разделим кодът ни на функции. Стекът може да се намира където операционната система реши, като мястото му се съхранява в {\tt esp} регистъра.

\subsubsection{Нива на привилегия}
Има четири нива на привилегироване, които варират от ниво 0 (най-привилегирован) до ниво 3. Това коя програма кое ниво на привилегия използва зависи от операционната система, като не е нужно всички нива да бъдат използвани.

\subsubsection{GDT (Global Descriptor Table)} \label{gdt}
Сегментите също ни позволяват да слагаме различни нива на достъп за всеки сегмент, като можем да контролираме за всяко ниво дали има достъп да чете, пише или изпълнява дадено парче от паметта. Това става чрез GDT таблицата, която на всеки ред описва сегмент и неговите права за достъп. Тази задача обаче се решава по-добре чрез странициране на паметта и заради това обикновено пълним GDT с минималният брой редове който е нужен.

\subsubsection{IDT (Interrupt Descriptor Table)} \label{idt}
IDT таблицата съдържа списъка от функции, които да се извикат при определено прекъсване. Тази таблица почти винаги е нужна, тъй като прекъсвания се генерират от външни устройства и от самия процесор.

\subsection{Видове криптиране}
Криптирането е процесът на разбъркване на съобщение по такъв начин че дори всеки да го чуе, само човекът към когото е адресирано съобщението да го разбере. Това се постига чрез съществуването на тайна информация която само адресантът има и му позволява да разбере съобщението. Методите за криптиране се делят на два вида: симетрично криптиране и асиметрично криптиране. При симетричното криптиране се използва една и съща тайна информация (т.нар. ключ) за кодиране и декодиране на съобщението. При асиметричното криптиране ключът за криптиране е публичен и всеки може да криптира съобщение, но ключът за декриптиране е различен и само получателя го притежава. При комуникация през интернет обикновено се използва асиметрично криптиране, защото за да си разменят двете страни симетричен ключ трябва или да се срещнат на живо или да използват асиметричен алгоритъм като Дифи-Хелман за размяна на симетричен ключ.

% software description (8-10 pages)
\newpage
\section{Избор на средства}
\subsection{Изисквания}
%Избрах да имплементирам RSA криптиране защото е популярен, стар и не толкова сложен алгоритъм за асиметрично криптиране. Общи знания за алгоритъма получих от видео серията "Public Key Cryptography"\parencite{artoftheproblemrsa} от "Art of the Problem". Конкретни детайли намирах в Wikipedia\parencite{wikipedia} защото Wikipedia предоставя много добри и пълни обяснения за каквото и да било свързано с математика.
% RSA on bare metal
% TODO
\subsection{Избор на език за програмиране и библиотеки} \label{langchoice}
% C, tiny-bignum-c, GRUB, QEMU
C е най-популярният и може би най-добрият език за писане на програми на ниско ниво и следователно е очевидният избор за проекта. Използвам чужд буутлоъдър защото няма смисъл да създавам мой и това е извън рамките на изискванията. Буутлоъдъра който избрах е GRUB. За реализацията на криптирането трябват числа по-големи от 32/64 бита, а C не идва с такива и за това се нуждаех от библиотека за големи числа. Повечето библиотеки обаче използват функии от libc които моето ядро не имплементира. Библиотеката на която се спрях е "tiny-bignum-c"\parencite{tinybignumc} защото е малка ($\sim500$ реда код), open-source, с отворен лиценз (Unlicense) и не ползва нищо от libc (включително и {\tt malloc}).

\subsection{Описание на алгоритъма}
\subsubsection{Първи задачи на ядрото}
Първото нещо което правим е да създадем стек за да можем да организираме кодът ни като функции и да можем да пишем на език различен от assembly.
% TODO

\subsubsection{VirtIO драйвер}
% virtqueues and stuff
% TODO
\subsubsection{RSA криптиране в детайли}
% math & formulas
% TODO

% implementation (10-15 pages)
\newpage
\section{Реализация}
% lots and lots of code snippets
% TODO

% usage manual (6-10 pages)
\newpage
\section{Ръководство на потребителя}
\subsection{Инсталация}

% conclusion (1 page)
\newpage
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

% citations (unbounded)
\newpage
\addcontentsline{toc}{section}{Литература}
\printbibliography

% table of contents
\newpage
\addcontentsline{toc}{section}{Съдържание}
\tableofcontents

\end{document}
