% software description (8-10 pages)
\section{Избор на средства} % a bad name for a hodgepodge section
\subsection{Изисквания}
% RSA on bare metal
Поставените изисквания: \textit{``Приложението трябва да криптира/декриптира данни с асиметрично криптиране изпратени по virtio-serial връзка до него и да връща резултата по същата връзка. Приложението трябва да имплементира virtio-serial връзката.''}

Избрах да имплементирам RSA криптиране защото е популярен, стар и не толкова сложен алгоритъм за асиметрично криптиране и следователно може да се намери много информация за него.

\subsection{Избор на език за програмиране и библиотеки} \label{langchoice}
% C, tiny-bignum-c, GRUB, QEMU
% Rust or Zig may have been better but I only know C
За програмиране от най-ниско ниво е задължително използването на асемблер, като използвах {\tt nasm} за асемблирането защото съм най-запознат с него. Но асемблер е неудобен за ползване, за това съм използвал и език от по-високо ниво. Изборът ми най-вече се състоеше между {\tt C} и {\tt Zig}. {\tt C} е един от най-популярните и най-широко разпространените езици за писане на код на ниско ниво и е много добър избор, но {\tt Zig} има много от същите функционалности, както и много други които биха направили писането на код много по-лесно и приятно. Проблемът със {\tt Zig} е, че е доста нов език и следователно няма почти никакви ресурси от които да го науча и за това се спрях на {\tt C}.

Използвам чужд буутлоъдър защото няма смисъл да създавам мой и това е извън рамките на изискванията. Буутлоъдъра който избрах е GRUB.

За реализацията на криптирането трябват числа по-големи от 32/64 бита, а {\tt C} не идва с такива и за това се нуждаех от библиотека за големи числа. Повечето библиотеки обаче използват функии от libc, които моето ядро не имплементира. Библиотеката на която се спрях е ``tiny-bignum-c''\parencite{tinybignumc} защото е малка ($\sim500$ реда код), open-source, с отворен лиценз\footnote{Това ми позволява да създам мое копие на софтуера и да го променям както пожелая} (Unlicense) и не ползва нищо от libc (включително и {\tt malloc}).

\subsection{Описание на алгоритмите}
При неяснота на значението на термини от рода на ``GDT'', ``IDT'', ``стек'', ``virtqueue'' и прочие може да ги намерите описани в подробности в глава \ref{research} - \nameref{research}.
\subsubsection{Първи задачи на ядрото}
Първото нещо което правим е да създадем стек за да можем да организираме кодът ни като функции и да можем да пишем на {\tt C}. След това изключваме прекъсванията и създаваме GDT и IDT таблици. GDT таблицата я пълним с два реда\footnote{Плюс трети, нулев ред, който е задължителен но не прави нищо}, които казват, че имаме достъп да пишем, четем и изпълняваме цялата памет. IDT таблицата я пълним с адресите на няколко функции, които само слагат край на каквото прекъсване бъде извикано с цел по-късно ако решим да ги заменим с адресите на функции, които правят нещо при прекъсване. След всичките тези настройки включваме прекъсванията и викаме главната функция {\tt kernel\_main}, която представлява приложението ни.

\subsubsection{RSA криптиране в детайли} \label{rsaalgo}
% math & formulas
Използват се няколко математически факта. Първият е че модулното експониране е еднопосочна функция. Т.е. ако знаем стойностите на $m$, $e$ и $n$ е много по-лесно да изчислим $m^e \equiv x \pmod n$ отколкото $x^e \equiv m \pmod n$. Това ни позволява да използваме тази операция за криптиране на съобщение, но ни трябва и метод за декриптиране. Нека $d$ е число така че ако $m^e \equiv x \pmod n$ то $x^d \equiv m \pmod n$. От това следва че:
$$m^{ed} \equiv m^{e^d} \equiv m \pmod n$$
$e$ и $n$ са публичният ключ, а $d$ и $n$ са тайният ключ. Нуждаем се само от начин за генериране на числото $d$ който само ние можем да изпълним.

Вторият факт е че разлагането на едно съставно число на простите му съставки е бавна операция, но умножаването на две прости числа за да получим съставно число е бърза операция. Т.е. ако генерираме две големи прости числа $p$ и $q$ и ги умножим, получаваме число чиито прости съставки само ние знаем.

Това е полезно в комбинация с третият факт, и той е една от теоремите на Ойлер:
$$a^{\phi(n)} \equiv 1 \pmod n$$
Където $\phi(n)$ е функцията на Ойлер, която за всяко число $n$ връща броя на естествените числа от 1 до $n$ които са взаимно прости с $n$. Примери:
\begin{equation*}
\begin{split}
  \phi(7) &= 6 \; (1,2,3,4,5,6)\\
  \phi(8) &= 4 \; (1,3,5,7) \\
  \phi(9) &= 6 \; (1,2,4,5,7,8) \\
\end{split}
\end{equation*}
В общият случай за случайно число $n$ е трудно да се пресметне стойността на тази функция, но ако $p$ и $q$ са две различни прости числа то знаем че:
\begin{equation*}
\begin{split}
\phi(p) &= p-1 \\
\phi(q) &= q-1 \\
\phi(pq) &= \phi(p)\phi(q) \\
&= (p-1)(q-1) \\
\end{split}
\end{equation*}
Следователно $\phi(n)$ е функция която е лесна да се пресметне само ако знаем как се разлага числото $n$. Ако се върнем в теоремата на Ойлер и направим няколко трансформации ще получим\ldots
\begin{alignat*}{2}
m^{\phi(n)} &\equiv 1 &\pmod n \\
m^{k\phi(n)} &\equiv 1^k &\pmod n \\
m^{k\phi(n)} &\equiv 1 &\pmod n \\
m\times m^{k\phi(n)} &\equiv m\times 1 &\pmod n \\
m^{k\phi(n)+1} &\equiv m &\pmod n \\
m^{e\frac{k\phi(n)+1}{e}} &\equiv m &\pmod n \\
m^{ed} &\equiv m &\pmod n\\
d &= \frac{k\phi(n)+1}{e} \\
\end{alignat*}
Където $k$ е каквото и да било число, като го избираме така че да получим цяло число като резултат за $d$. За изчисляването на $d$ е нужно да се изчисли $\phi(n)$, което става бързо само ако са известни простите множители на $n$. Следователно ако генерираме две тайни прости числа $p$ и $q$ и използваме $p\times q$ за $n$ то само ние ще можем да пресметнем $d$.

Остават още няколко детайла за изясняване, един от които е как се изчисляват големите прости числа $p$ и $q$ бързо. Това е обяснено в част \ref{fermatprimes}. Другите детайли са как избираме $e$ и $k$.

Избираме $e$ така че $\gcd(\phi(n), e) = 1$, където $\gcd(a,b)$ е най-голямото общо кратно на $a$ и $b$. Най-често за $e$ се използва стойността 65537 ($2^{16}+1$). $k$ изчисляваме като използваме разширеният алгоритъм на Евклид, който за две дадени цели числа $a$ и $b$ намира две цели числа $x$ и $y$ така че следното уравнение да е вярно: (т.нар. тъждество на Безу)
$$ ax + by = \gcd(a,b) $$
Ако $a = \phi(n)$ и $b = e$ то следва че:
\begin{alignat*}{2}
d = \frac{ka+1}{b} \\
ka + 1 &\equiv 0 &\pmod b \\
ka + \gcd(a,b) &\equiv 0 &\pmod b \\
ka + ax + by &\equiv 0 &\pmod b \\
ka + ax &\equiv 0 &\pmod b \\
a(k+x) &\equiv 0 &\pmod b \\
a(b-x+x) &\equiv 0 &\pmod b \\
k = b-x \\
\end{alignat*}
Разширеният алгоритъм на Евклид намира $x$ и $y$ така че $|x|\leq|b/\gcd(a,b)|$ и $|y|\leq|a/\gcd(a,b)|$. Равенство може да се получи само ако $\gcd(a,b)=a$ или $\gcd(a,b)=b$, но понеже в нашият случай $\gcd(a,b)=1$ и $a \neq 1 \neq b$ следва че $|x|<|b|$, и тъй като $b>0$ е гарантирано $b-x$ да e положително цяло число.

\subsubsection{Алгоритъм за намиране на големи прости числа} \label{fermatprimes}
Обикновените алгоритми за намиране на прости числа (като напр. решетото на Ератостен) намират всички прости числа между 1 и някакво число $N$, но на нас не ни трябват много прости числа, а само едно. Също така не е нужно да сме 100\% сигурни че числото което сме намерили е просто, защото дори да има 0.0000000001\% шанс да генерираме съставно число, алгоритъмът ни все пак ще е достатъчно добър на практика.

Алгоритъмът който се използва се базира на малката теорема на Ферма, която казва че за всяко цяло число $a$ и всяко просто число $p$ важи следното:
$$ a^p \equiv a \pmod p $$
Но в случай че не знаем дали $p$ е просто, можем да използваме същата теорема за да проверим, като изпробваме различни стойности на $a$. Ако намерим стойност за $a$ където уравнението не е вярно то знаем че $p$ не е просто, но ако след десетки опити не открием такова число, можем да сме сравнително убедени, че $p$ е просто число.

Изключение от това правило са числата на Кармайкъл. Това са всички съставни числа за които теоремата на Ферма все пак важи за всяко цяло число $a$. Те са рядкост но могат да се премахнат чрез използването на още един, различен тест за тестване дали $p$ е просто.

\subsubsection{Алгоритъм за бързо експониране на големи числа}
Наивният алгоритъм за изчисляване на $a^b$ е да умножим $a$ по себе си $b$ пъти, но това е $\mathcal{O}(b)$ алгоритъм и за големи стойности на $b$ става непоносимо бавен. За това използвам бинарно експониране което е $\mathcal{O}(\log b)$ алгоритъм за постигане на същата цел.

Първото което трябва да забележим е че:
$$ x^y \times x^z = x^{y+z} $$
Следователно всяка степен $b$ можем да я разчупим на множество степени на двойката които после да съберем заедно. Пример:
$$ a^{13} = a^8 \times a^4 \times a^1 $$
Това ни помага защото изчисляването на $a^{(2^x)}$ е лесно и отнема $\mathcal{O}(x)$ време:
$$ a^{(2^x)} = (a^{(2^{x-1})})^2$$
Тъй като повдигането на квадрат се постига лесно чрез умножаване на числото по себе си.

Финалният алгоритъм изглежда по следния начин:
\begin{lstlisting}[language=C]
void exponentiation(ii* b_in, ii* e_in, ii* res) {
  inii(b); // b = b_in
  inii(e); // e = e_in

  mkii(temp); // ii temp
  ii one; bignum_from_int(&one, 1);

  bignum_from_int(res, 1); // res = 1
  while (!bignum_is_zero(e)) { // while (e != 0) {
    if (e->array[0]&1) { // if (e & 1) {
      // res *= b
      bignum_mul(res, b, temp);
      bignum_assign(res, temp);
    }
    // b *= b
    bignum_mul(b, b, temp);
    bignum_assign(b, temp);
    // e = e >> 1
    bignum_rshift(e, temp, 1);
    bignum_assign(e, temp);
  }
}
\end{lstlisting}

\subsubsection{Алгоритъма на Карацуба за бързо умножение на две големи числа}
Алгоритъма за умножение който всички знаем от училище изисква $\mathcal{O}(n^2)$ време. Алгоритъма на Карацуба е рекурсивен метод за умножение който изисква само $\mathcal{O}(n^{\log_2 3}) \approx \mathcal{O}(n^{1.58})$ време. Ако са ни дадени числата $x$ и $y$ и трябва да намерим $x \times y$ първото което правим е да разчупим числата по следния начин:
\begin{equation*}
\begin{split}
  x = x_1B+x_0 \\
  y = y_1B+y_0 \\
\end{split}
\end{equation*}
Където $B$ ако работим с бинарни числа е степен на двойката. От това намираме че:
\begin{equation*}
\begin{split}
  x \times y &= (x_1B+x_0) \times (y_1B+y_0) \\
             &= z_2B^2+z_1B+z_0 \\
\end{split}
\end{equation*}
където
\begin{equation*}
\begin{split}
  z_0 &= x_0y_0 \\
  z_1 &= x_1y_0 + x_0y_1 \\
  z_2 &= x_1y_1 \\
\end{split}
\end{equation*}
Тези формули изискват 4 умножения и следователно ако спрем тук рекурсията отново ще бъде $\mathcal{O}(n^2)$. Но не спираме тук а виждаме че $z_1$ можем да го изчислим само с 1 умножение вместо с 2 по следния начин:
$$ z_1 = (x_1+x_0)(y_1+y_0) - z_2 - z_0 $$
И с това приключва описанието на алгоритъма. В базовия случай когато числата станат твърде малки използваме вградената инструкция за умножение на процесора или ако това не е опция просто използваме обиковения алгоритъм за умножение.

