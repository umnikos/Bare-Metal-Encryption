% software description (8-10 pages)
% choices made and reasoning
\chapter{Реализиране} % FIXME
\section{Функционални изисквания към bare-metal приложение за асиметрично криптиране}
Приложението трябва да:
\begin{itemize}
  \item бъде bare-metal
  \item работи във QEMU виртуална машина
  \item криптира/декриптира данни
  \item с асиметрично криптиране
  \item изпратени и получени по сериина връзка
  \item приложението трябва да имплементира сериината връзка
  \item сериината връзка трябва да е virtio-serial връзка
\end{itemize}

\section{Избор на език за програмиране и компилатор}
За разработката на bare-metal приложение за x86 архитектура е задължително да се използва, поне от части, асемблер. Асемблатора, използван в проекта, е {\tt NASM}. Но разработването на целия проект само с асемблер би било бавно и трудно и за това е използван и език от по-високо ниво.

Малко езици от високо ниво са подходящи за разработване на bare-metal приложение. Езиците, които ще бъдат разгледани тук са {\tt C} и {\tt Zig}.

{\tt C} е език с дълга история и е един от най-широко разпространените езици от високо ниво за писане на код от ниско ниво. Позволява лесно да се интегрира с асемблер чрез своето широко поддържано и лесно за използване {\tt System V ABI}\parencite{sysvabi} и като цяло е добър избор за какъвто и да било проект. Ядрото на Linux операционната система е почти изцяло написано на {\tt C}.

{\tt Zig} е (по време на писането на този документ) доста нов език, който се цели да замени {\tt C} и да предостави нови удобства за програмиста\parencite{whyzig}. Най-големият му проблем идва именно от това, че е нов - документацията му е оскъдна и няма написани книги от където да бъде научен в детайли. Именно заради това не беше избран за този проект, а вместо него беше избран езикът {\tt C}.

Под въпрос е и как ще бъде компилиран кодът. Компилаторът трябва да знае, че компилираният машинен код няма да върви върху операционна система и няма да има достъп до {\tt libc} - стандартната {\tt C} библиотека. Един от възможните начини е да се използва стандартен {\tt C} компилатор и да му се подадат купчина флагове, които да му казват точно това. Друг начин е да се направи cross-compiler (компилатор от една среда към друга). Трети е да се използва {\tt Zig} компилатора като {\tt C} компилатор със следната команда:
{\tt zig cc -target i386-freestanding}.
Най-голям успех бе постигнат с втория метод, въпреки че е и най-трудоемкия.

\section{Избор на алгоритъм за асиметрично криптиране}
RSA е един от първите алгоритми за асиметрично криптиране и до ден днешен е широко разпространен. Не е сложен за реализация и съществува голямо количество достъпна информация, описваща начина му на работа.\cite{artoftheproblemrsa}\cite{rsapaper}

\section{Избор на библиотеки и други средства}
Не е невъзможно да се направи буутлоъдър специално за проекта, но е извън рамките на изискванията и за това е използван GRUB като такъв.

За реализацията на проекта е нужна и имплементация на големи числа (числа, които заемат повече от 32 бита в паметта). Съществуват много такива библиотеки, но повечето от тях разчитат на наличието на операционна система и за това не са подходящи за проекта. {\tt tiny-bignum-c}\cite{tinybignumc} е едно от изключенията. Имплементацията не разчита на функции като {\tt malloc} и улеснява разработката. Големият минус на библиотеката е, че е бавна. Но благодарение на това, че библиотеката е малка ($\sim 500$ реда код) и с отворен лиценз (Unlicense), този проблем беше от части решен чрез замяната на част от алгоритмите с по-добри. Новите алгоритми са описани в точки \ref{binexp} и \ref{karatsuba}.

\section{Описание на използваните алгоритми} \label{algos}
  % INCLUDE PICTURES
  \subsection{Обяснение на RSA алгоритъма}
  % TODO

  \subsection{Алгоритъм за бързо намиране на големи прости числа използвайки малката теорема на Ферма} \label{primesalgo}
  Алгоритмите за намиране на прости числа като решетото на Ератостен\cite{primesieve} намират всички прости числа между 1 и някаква горна граница $N$, но ако $N$ е голямо това е бавен процес. Но за целта на RSA не е нужен голям брой прости числа, а само две, много големи прости числа. Също така на практика не е нужно числата, които биват генерирани, да са доказуемо прости, стига шансът да не са прости да е много, много малък.

  Алгоритъмът, който се използва се базира на малката теорема на Ферма, която гласи, че за всяко цяло число $a$ и всяко просто число $p$ важи следното тъждество:
  \begin{equation}
    a^p \equiv a \pmod{p}
    \label{fermat}
  \end{equation}
  Но в случай, че не се знае дали $p$ е просто, тъждеството може да бъде използвано като метод за проверка. При избирането на различни стойности за $a$ ако бъде намерена стойност, при която тъждеството не важи, то със сигурност $p$ не е просто число. Но ако след десетки опити не бъде открито такава стойност за $a$, то има голям шанс $p$ да е просто.
  Съществуват съставни числа $p$, за които тъждеството \ref{fermat} важи за всяка стойност на $a$, въпреки че не са прости. Това са числата на Кармайкъл и са сравнително редки.\cite{carmichaelrare} % TODO - second primality check

  \subsection{Превръщане на съобщение в число и обратно} \label{paddingscheme}
  RSA работи върху числа, но съобщенията, които най-често се изпращат, са данни. За щастие тези данни могат да се представят като байтове, а всеки байт реално представлява число. Няколко байта един до друг представляват по-голямо число, но не може да бъде изпратено едно дълго съобщение като едно число, защото поради начина на работа на RSA декриптираното число винаги ще бъде между $0$ и $N-1$, следователно оригиналното число трябва да е по-малко от $N$ за да няма загуба на информация. Това се постига лесно като се раздели съобщението на няколко части и се криптират/декриптират отделно. Това разделяне, обаче, трябва да се направи внимателно. Ако всяко парче просто бъде криптирано и изпратено, то две еднакви парчета ще се криптират по един и същи начин. Проблемът става по-очевиден при размер на парчетата равен на една буква. Решението е просто - добавяне на случайни байтове към началото или края на всяко парче, които да бъдат игнорирани от получателя. Количеството байтове трябва да е по-голямо за по-дълги съобщения за да се минимизира шансът от повторения.

  \subsection{Алгоритъм за бързо експониране на големи числа (бинарно експониране)} \label{binexp}
  Най-простият алгоритъм за изчисляване на $a^b$ е да се умножи $a$ по себе си $b$ брой пъти. Този алгоритъм отнема $\mathcal{O}(b)$ умножения, което го прави непоносимо бавен за големи стойности на $b$. Бинарното експониране е по-бърз алгоритъм, който отнема само $\mathcal{O}(\log b)$ умножения.
  Първото, което трябва да се забележи, е следното:
  \begin{equation}
    a^x \times a^y = a^{x + y}
    \label{exp-breakability}
  \end{equation}
  От това следва, че всяка степен $b$ може да се представи като различни степени на двойката, които после да бъдат събрани заедно в един общ резултат. Пример за това е даден в уравнение \ref{exp-breakability-example}:
  \begin{equation}
    a^{13} = a^8 \times a^4 \times a^1
    \label{exp-breakability-example}
  \end{equation}
  Това само по себе си не помага, защото ако изчисляването на $a^{16}$ отнема 15 умножения, то финалният брой умножения остава същия. Но има по-бърз метод, който бива демонстриран в уравнение \ref{exp-squaring-example}. Ключото наблюдение, което трябва да бъде направено, е че $a^8$ трябва да се изчисли само веднъж:
  \begin{equation}
    a^{16} = a^8 \times a^8
    \label{exp-squaring-example}
  \end{equation}
  Ако $a^8$ отнема 7 умножения, то $a^{16}$ ще отнеме 8. Но реално съшият метод може да се приложи и за $a^8$, $a^4$ и т.н. В общия случай важи следното (като подвигането на квадрат изисква само едно умножение):
  \begin{equation}
    a^{2^x} = (a^{2^{x-1}})^2
    \label{exp-squaring}
  \end{equation}
Ако тъждеството \ref{exp-squaring} се повтори до достигането на $a^1$ ($a^{2^0}$) се получават точно $x$ (или $\log_2 2^x$) повдигания на квадрат. Това прави финалният алгоритъм за какъвто и да било експонент $b$ да отнема най-много $2 \times \lfloor \log_2 b \rfloor$ умножения, което е еквивалентно на $\mathcal{O}(\log b)$

  Фигура \ref{fig:binexp} показва пълната имплементация на алгоритъма.

  \begin{figure}[p]
    \caption{Имплементация на бинарно експониране}
    \label{fig:binexp}
    \begin{lstlisting}[language=C]
    void exponentiation(ii* b_in, ii* e_in, ii* res) {
      inii(b); // b = b_in
      inii(e); // e = e_in

      mkii(temp); // ii temp
      ii one; bignum_from_int(&one, 1);

      bignum_from_int(res, 1); // res = 1
      while (!bignum_is_zero(e)) { // while (e != 0) {
        if (e->array[0]&1) { // if (e & 1) {
          // res *= b
          bignum_mul(res, b, temp);
          bignum_assign(res, temp);
        }
        // b *= b
        bignum_mul(b, b, temp);
        bignum_assign(b, temp);
        // e = e >> 1
        bignum_rshift(e, temp, 1);
        bignum_assign(e, temp);
      }
    }
    \end{lstlisting}
  \end{figure}

  \subsection{Алгоритъм за бързо умножение на големи числа (алгоритъма на Карацуба)} \label{karatsuba}

