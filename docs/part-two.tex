% software description (8-10 pages)
\section{Избор на средства}
\subsection{Изисквания}
% RSA on bare metal
Поставените изисквания: \textit{Приложението трябва да криптира/декриптира данни с асиметрично криптиране изпратени по virtio-serial връзка до него и да връща резултата по същата връзка. Приложението трябва да имплементира virtio-serial връзката.}

Избрах да имплементирам RSA криптиране защото е популярен, стар и не толкова сложен алгоритъм за асиметрично криптиране и следователно е добре описан в интернет.

\subsection{Избор на език за програмиране и библиотеки} \label{langchoice}
% C, tiny-bignum-c, GRUB, QEMU
% Rust or Zig may have been better but I only know C
За програмиране от най-ниско ниво е задължително използването на асемблер\footnote{Използвах {\tt nasm} за асемблирането защото съм най-запознат с него.}. Но само асемблер е неудобно за ползване, за това съм използвал и {\tt C}. {\tt C} е най-популярният и един от най-добрите езици за писане на код от ниско ниво и следователно беше доста добър избор за проекта. {\tt Zig} може би щеше да бъде по-добър избор но не съм запознат с него и поради новостта му няма голям брой източници от които да го науча.

Използвам чужд буутлоъдър защото няма смисъл да създавам мой и това е извън рамките на изискванията. Буутлоъдъра който избрах е GRUB.

За реализацията на криптирането трябват числа по-големи от 32/64 бита, а {\tt C} не идва с такива и за това се нуждаех от библиотека за големи числа. Повечето библиотеки обаче използват функии от libc, които моето ядро не имплементира. Библиотеката на която се спрях е ``tiny-bignum-c''\parencite{tinybignumc} защото е малка ($\sim500$ реда код), open-source, с отворен лиценз\footnote{Това ми позволява да създам мое копие на софтуера и да го променям както пожелая} (Unlicense) и не ползва нищо от libc (включително и {\tt malloc}).

\subsection{Описание на алгоритмите}
Ако не разбирате някой термин, потърсете го в глава \ref{research} - \nameref{research}
\subsubsection{Първи задачи на ядрото}
Първото нещо което правим е да създадем стек за да можем да организираме кодът ни като функции и да можем да пишем на {\tt C}. След това изключваме прекъсванията и създаваме GDT и IDT таблици. GDT таблицата я пълним с два реда\footnote{Плюс трети, нулев ред, който е задължителен но не прави нищо}, които казват че имаме достъп да пишем, четем и изпълняваме цялата памет. IDT таблицата я пълним с адресите на две функции които не правят нищо освен да сложат край на прекъсването. Тях можем после да ги заменим с адресите на функции, които правят нещо при прекъсване. След това включваме прекъсванията и викаме главната функция, която стартира апликацията ни.

\subsubsection{RSA криптиране в детайли}
% math & formulas
% TODO
Използват се няколко математически трика. Първият е че модулното експониране е еднопосочна функция. Т.е. ако знаем стойностите на $m$, $e$ и $n$ е много по-лесно да изчислим $m^e \equiv x \pmod n$ отколкото $x^e \equiv m \pmod n$. Това ни позволява да използваме тази операция за криптиране на съобщение, но ни трябва и метод за декриптиране. Нека $d$ е число така че ако $m^e \equiv x \pmod n$ то $x^d \equiv m \pmod n$. От това следва че:
$$m^{ed} \equiv m^{e^d} \equiv m \pmod n$$
$e$ и $n$ са публичният ключ, а $d$ и $n$ са тайният ключ. Нуждаем се само от начин за генериране на числото $d$ който само ние можем да изпълним.

Вторият трик е че разлагането на едно композитно число на простите му съставки е бавна операция, но умножаването на две прости числа за да получим композитно число е бърза операция. Т.е. ако генерираме две големи прости числа $p$ и $q$ и ги умножим, получаваме число чиито прости съставки само ние знаем.

Това е полезно в комбинация с третият трик, и той е една от теоремите на Ойлер:
$$a^{\phi(n)} \equiv 1 \pmod n$$
Където $\phi(n)$ е функцията на Ойлер, която за всяко число $n$ връща броя на естествените числа от 1 до $n$ които за взаимно прости с $n$. Примери:
\begin{equation*}
\begin{split}
\phi(7) &= 6 \\
\phi(8) &= 4 \\
\phi(9) &= 6 \\
\end{split}
\end{equation*}
В общият случай за случайно число $n$ е трудно да се пресметне стойността на тази функция, но ако $p$ и $q$ са две различни прости числа то знаем че:
\begin{equation*}
\begin{split}
\phi(p) &= p-1 \\
\phi(q) &= q-1 \\
\phi(pq) &= \phi(p)\phi(q) \\
&= (p-1)(q-1) \\
\end{split}
\end{equation*}
Следователно $\phi(n)$ е функция която е лесна да се пресметне само ако знаем как се разлага числото $n$. Ако се върнем в теоремата на Ойлер и направим няколко трансформации ще получим\ldots
\begin{alignat*}{2}
m^{\phi(n)} &\equiv 1 &\pmod n \\
m^{k\phi(n)} &\equiv 1^k &\pmod n \\
m^{k\phi(n)} &\equiv 1 &\pmod n \\
m\times m^{k\phi(n)} &\equiv m\times 1 &\pmod n \\
m^{k\phi(n)+1} &\equiv m &\pmod n \\
m^{e\frac{k\phi(n)+1}{e}} &\equiv m &\pmod n \\
m^{ed} &\equiv m &\pmod n\\
d &= \frac{k\phi(n)+1}{e} \\
\end{alignat*}
Където $k$ е каквото и да било число, като го избираме така че да получим целочислен резултат за $d$. За изчисляването на $d$ е нужно да се изчисли $\phi(n)$, което става бързо само ако са известни простите множители на $n$. Следователно ако генерираме две тайни прости числа $p$ и $q$ и използваме $p\times q$ за $n$ то само ние ще можем да пресметнем $d$.

Остават още няколко детайла за изясняване, един от които е как се изчисляват големи прости числа бързо. На този въпрос е отговорено в част \ref{fermatprimes}. Другите детайли са как избираме $e$ и $k$.

Избираме $e$ така че $\gcd(\phi(n), e) = 1$, където $\gcd(a,b)$ е най-голямото общо кратно на $a$ и $b$. Най-често за $e$ се използва стойността 65537. $k$ изчисляваме като използваме разширеният алгоритъм на Евклид, който за две дадени цели числа $a$ и $b$ намира две цели числа $x$ и $y$ така че следното уравнение да е вярно: (т.нар. тъждество на Безу)
$$ ax + by = \gcd(a,b) $$
Ако $a = \phi(n)$ и $b = e$ то следва че:
\begin{alignat*}{2}
d = \frac{ka+1}{b} \\
ka + 1 &\equiv 0 &\pmod b \\
ka + \gcd(a,b) &\equiv 0 &\pmod b \\
ka + ax + by &\equiv 0 &\pmod b \\
ka + ax &\equiv 0 &\pmod b \\
a(k+x) &\equiv 0 &\pmod b \\
a(b-x+x) &\equiv 0 &\pmod b \\
k = b-x \\
\end{alignat*}
Разширеният алгоритъм на Евклид намира $x$ и $y$ така че $|x|\leq|b/\gcd(a,b)|$ и $|y|\leq|a/\gcd(a,b)|$. Равенство може да се получи само ако $\gcd(a,b)=a$ или $\gcd(a,b)=b$, но понеже в нашият случай $\gcd(a,b)=1\neq a\neq b$ следва че $|x|<|b|$, и тъй като $b>0$ е гарантирано $b-x$ да e положително цяло число.

\subsubsection{Алгоритъм за намиране на големи прости числа} \label{fermatprimes}
% TODO

\subsubsection{Алгоритъм за бързо експониране на големи числа}
% TODO
