% software description (8-10 pages)
% choices made and reasoning
\chapter{Реализиране} % FIXME
\section{Функционални изисквания към bare-metal приложение за асиметрично криптиране}
Приложението трябва да:
\begin{itemize}
  \item бъде bare-metal
  \item работи във QEMU виртуална машина
  \item криптира/декриптира данни
  \item с асиметрично криптиране
  \item изпратени и получени по сериина връзка
  \item приложението трябва да имплементира сериината връзка
  \item сериината връзка трябва да е virtio-serial връзка
\end{itemize}

\section{Избор на език за програмиране и компилатор}
За разработката на bare-metal приложение за x86 архитектура е задължително да се използва, поне от части, асемблер. Асемблатора, използван в проекта, е {\tt NASM}. Но разработването на целия проект само с асемблер би било бавно и трудно и за това е използван и език от по-високо ниво.

Малко езици от високо ниво са подходящи за разработване на bare-metal приложение. Езиците, които ще бъдат разгледани тук са {\tt C} и {\tt Zig}.

{\tt C} е език с дълга история и е един от най-широко разпространените езици от високо ниво за писане на код от ниско ниво. Позволява лесно да се интегрира с асемблер чрез своето широко поддържано и лесно за използване {\tt System V ABI}\parencite{sysvabi} и като цяло е добър избор за какъвто и да било проект. Ядрото на Linux операционната система е почти изцяло написано на {\tt C}.

{\tt Zig} е (по време на писането на този документ) доста нов език, който се цели да замени {\tt C} и да предостави нови удобства за програмиста\parencite{whyzig}. Най-големият му проблем идва именно от това, че е нов - документацията му е оскъдна и няма написани книги от където да бъде научен в детайли. Именно заради това не беше избран за този проект, а вместо него беше избран езикът {\tt C}.

Под въпрос е и как ще бъде компилиран кодът. Компилаторът трябва да знае, че компилираният машинен код няма да върви върху операционна система и няма да има достъп до {\tt libc} - стандартната {\tt C} библиотека. Един от възможните начини е да се използва стандартен {\tt C} компилатор и да му се подадат купчина флагове, които да му казват точно това. Друг начин е да се направи cross-compiler (компилатор от една среда към друга). Трети е да се използва {\tt Zig} компилатора като {\tt C} компилатор със следната команда:
{\tt zig cc -target i386-freestanding}.
Най-голям успех бе постигнат с втория метод, въпреки че е и най-трудоемкия.

\section{Избор на алгоритъм за асиметрично криптиране}
RSA е един от първите алгоритми за асиметрично криптиране и до ден днешен е широко разпространен. Не е сложен за реализация и съществува голямо количество достъпна информация, описваща начина му на работа.\cite{artoftheproblemrsa}\cite{rsapaper}

\section{Избор на библиотеки и други средства}
Не е невъзможно да се направи буутлоъдър специално за проекта, но е извън рамките на изискванията и за това е използван GRUB като такъв.

За реализацията на проекта е нужна и имплементация на големи числа (числа, които заемат повече от 32 бита в паметта). Съществуват много такива библиотеки, но повечето от тях разчитат на наличието на операционна система и за това не са подходящи за проекта. {\tt tiny-bignum-c}\cite{tinybignumc} е едно от изключенията. Имплементацията не разчита на функции като {\tt malloc} и улеснява разработката. Големият минус на библиотеката е, че е бавна. Но благодарение на това, че библиотеката е малка ($\sim 500$ реда код) и с отворен лиценз (Unlicense), този проблем беше от части решен чрез замяната на част от алгоритмите с по-добри. Новите алгоритми са описани в точки \ref{binexp} и \ref{karatsuba}.

\section{Описание на използваните алгоритми} \label{algos}
  % INCLUDE PICTURES
  \subsection{Обяснение на RSA алгоритъма}
  % TODO

  \subsection{Алгоритъм за бързо намиране на големи прости числа използвайки малката теорема на Ферма} \label{primesalgo}
  Алгоритмите за намиране на прости числа като решетото на Ератостен\cite{primesieve} намират всички прости числа между 1 и някаква горна граница $N$, но ако $N$ е голямо това е бавен процес. Но за целта на RSA не е нужен голям брой прости числа, а само две, много големи прости числа. Също така на практика не е нужно числата, които биват генерирани, да са доказуемо прости, стига шансът да не са прости да е много, много малък.

  Алгоритъмът, който се използва се базира на малката теорема на Ферма, която гласи, че за всяко цяло число $a$ и всяко просто число $p$ важи следното тъждество:
  \begin{equation}
    a^p \equiv a \pmod{p}
    \label{fermat}
  \end{equation}
  Но в случай, че не се знае дали $p$ е просто, тъждеството може да бъде използвано като метод за проверка. При избирането на различни стойности за $a$ ако бъде намерена стойност, при която тъждеството не важи, то със сигурност $p$ не е просто число. Но ако след десетки опити не бъде открито такава стойност за $a$, то има голям шанс $p$ да е просто.
  Съществуват съставни числа $p$, за които тъждеството \ref{fermat} важи за всяка стойност на $a$, въпреки че не са прости. Това са числата на Кармайкъл и са сравнително редки.\cite{carmichaelrare} % TODO - second primality check

  \subsection{Превръщане на съобщение в число и обратно} \label{paddingscheme}

  \subsection{Алгоритъм за бързо експониране на големи числа (бинарно експониране)} \label{binexp}

\begin{figure}[p]
\caption{Имплементация на бинарно експониране}
% TODO
\begin{lstlisting}[language=C]
void exponentiation(ii* b_in, ii* e_in, ii* res) {
  inii(b); // b = b_in
  inii(e); // e = e_in

  mkii(temp); // ii temp
  ii one; bignum_from_int(&one, 1);

  bignum_from_int(res, 1); // res = 1
  while (!bignum_is_zero(e)) { // while (e != 0) {
    if (e->array[0]&1) { // if (e & 1) {
      // res *= b
      bignum_mul(res, b, temp);
      bignum_assign(res, temp);
    }
    // b *= b
    bignum_mul(b, b, temp);
    bignum_assign(b, temp);
    // e = e >> 1
    bignum_rshift(e, temp, 1);
    bignum_assign(e, temp);
  }
}
\end{lstlisting}
\end{figure}

  \subsection{Алгоритъм за бързо умножение на големи числа (алгоритъма на Карацуба)} \label{karatsuba}

