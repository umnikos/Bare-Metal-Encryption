% software description (8-10 pages)
\section{Избор на средства}
\subsection{Изисквания}
% RSA on bare metal
Поставените изисквания: \textit{Приложението трябва да криптира/декриптира данни с асиметрично криптиране изпратени по virtio-serial връзка до него и да връща резултата по същата връзка. Приложението трябва да имплементира virtio-serial връзката.}

Избрах да имплементирам RSA криптиране защото е популярен, стар и не толкова сложен алгоритъм за асиметрично криптиране и следователно е добре описан в интернет.

\subsection{Избор на език за програмиране и библиотеки} \label{langchoice}
% C, tiny-bignum-c, GRUB, QEMU
% TODO - better argumentation for the language of choice
C е най-популярният и може би най-добрият език за писане на програми на ниско ниво и следователно е очевидният избор за проекта. Използвам чужд буутлоъдър защото няма смисъл да създавам мой и това е извън рамките на изискванията. Буутлоъдъра който избрах е GRUB. За реализацията на криптирането трябват числа по-големи от 32/64 бита, а C не идва с такива и за това се нуждаех от библиотека за големи числа. Повечето библиотеки обаче използват функии от libc, които моето ядро не имплементира. Библиотеката на която се спрях е "tiny-bignum-c"\parencite{tinybignumc} защото е малка ($\sim500$ реда код), open-source, с отворен лиценз\footnote{Това ми позволява да създам мое копие на софтуера и да го променям както пожелая} (Unlicense) и не ползва нищо от libc (включително и {\tt malloc}).

\subsection{Описание на алгоритъма}
Ако не разбирате някой термин, потърсете го в глава \ref{research} - \nameref{research}
\subsubsection{Първи задачи на ядрото}
Първото нещо което правим е да създадем стек за да можем да организираме кодът ни като функции и да можем да пишем на C. След това изключваме прекъсванията и създаваме GDT и IDT таблици. GDT таблицата я пълним с два реда\footnote{Плюс трети, нулев ред, който е задължителен но не прави нищо}, които казват че имаме достъп да пишем, четем и изпълняваме цялата памет. IDT таблицата я пълним с адресите на две функции които не правят нищо освен да сложат край на прекъсването. Тях можем после да ги заменим с адресите на функции, които правят нещо при прекъсване. След това включваме прекъсванията и викаме главната функция, която стартира апликацията ни.

\subsubsection{VirtIO драйвер}
% virtqueues and stuff
% TODO
\subsubsection{RSA криптиране в детайли}
% math & formulas
% TODO
