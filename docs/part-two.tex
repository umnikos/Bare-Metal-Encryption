% software description (8-10 pages)
% choices made and reasoning
\chapter{Реализиране} % FIXME
\section{Функционални изисквания към bare-metal приложение за асиметрично криптиране}
Изискванията, поставени върху проекта, са следните:
\begin{itemize}
  \item Приложението трябва да бъде bare-metal (да работи без операционна система)
  \item Приложението трябва да работи върху QEMU виртуална машина
  \item Приложението трябва да криптира/декриптира данни
  \item Данните трябва да се криптират/декриптират с асиметрично криптиране
  \item Данните трябва да могат да бъдат изпратени и получени по сериина връзка
  \item Приложението трябва да имплементира сериината връзка
  \item Сериината връзка трябва да е virtio-serial връзка
\end{itemize}

\section{Избор на език за програмиране и компилатор}
За разработката на bare-metal приложение за x86 архитектура е задължително да се използва, поне от части, асемблер. Асемблатора, използван в проекта, е {\tt NASM}. Но разработването на целия проект само с асемблер би било бавно и трудно и за това е използван и език от по-високо ниво.

Малко езици от високо ниво са подходящи за разработване на bare-metal приложение. Езиците, които биват разгледани тук са {\tt C} и {\tt Zig}.

{\tt C} е език с дълга история и е един от най-широко разпространените езици от високо ниво за писане на код от ниско ниво. Позволява лесно да се интегрира с асемблер чрез своето широко поддържано и лесно за използване {\tt System V ABI}\cite{sysvabi} и като цяло е добър избор за какъвто и да било проект. Ядрото на Linux операционната система е почти изцяло написано на {\tt C}.\cite{linux-source}

{\tt Zig} е (по време на писането на този документ) доста нов език, който се цели да замени {\tt C} и да предостави нови удобства за програмиста.\cite{whyzig} Най-големият му проблем идва именно от това, че е нов - документацията му е оскъдна и няма написани книги от където да бъде научен в детайли. Именно заради това не беше избран за този проект, а вместо него беше избран езикът {\tt C}.

Под въпрос е и как ще бъде компилиран кодът. Компилаторът трябва да знае, че компилираният машинен код няма да върви върху операционна система и няма да има достъп до {\tt libc} - стандартната {\tt C} библиотека. Един от възможните начини е да се използва стандартен {\tt C} компилатор и да му се подадат купчина флагове, които да му казват точно това. Друг начин е да се направи cross-compiler (компилатор от една среда към друга). Трети е да се използва {\tt Zig} компилатора като {\tt C} компилатор със следната команда:
{\tt zig cc -target i386-freestanding}.
Най-голям успех бе постигнат с втория метод, въпреки че е и най-трудоемкия.

\section{Избор на алгоритъм за асиметрично криптиране}
RSA е един от първите алгоритми за асиметрично криптиране и до ден днешен е широко разпространен. Не е сложен за реализация и съществува голямо количество достъпна информация, описваща начина му на работа.\cite{artoftheproblemrsa, rsapaper}

\section{Избор на библиотеки и други средства}
Не е невъзможно да се направи буутлоъдър специално за проекта, но е извън рамките на изискванията и за това е използван GRUB.

За реализацията на проекта е нужна и имплементация на големи числа (числа, които заемат повече от 32 бита в паметта). Съществуват много такива библиотеки, но повечето от тях разчитат на наличието на операционна система и за това не са подходящи за проекта. {\tt tiny-bignum-c}\cite{tinybignumc} е едно от изключенията. Имплементацията не разчита на функции като {\tt malloc} и улеснява разработката. Големият минус на библиотеката е, че е бавна. Но благодарение на това, че библиотеката е малка ($\sim 500$ реда код) и с отворен лиценз (Unlicense), този проблем беше от части решен чрез замяната на част от алгоритмите с по-добри. Новите алгоритми са описани в точки \ref{binexp} и \ref{karatsuba}. След приключването на разработката бяха открити други, по-добри библиотеки\cite{tomsfastmath, bignum-embedded}, които са достатъчно бързи че да не се налага да бъдат модифицирани.

\section{Описание на използваните алгоритми} \label{algos}
  \subsection{Обяснение на RSA алгоритъма} \label{rsa}
  В RSA криптирането се използват няколко математически факта. Първият от тях е, че модулното експониране е еднопосочна функция. Т.е. ако се знаят стойностите на $m$, $e$ и $n$ е много по-лесно да се изчисли $m^e \equiv x \pmod{n}$ отколкото $x^e \equiv m \pmod{n}$. Това позволява тази операция да се използва за криптиране на съобщение, но е нужен и метод за декриптиране. Нека $d$ е число, така че ако $m^e \equiv x \pmod{n}$ то $x^d \equiv m \pmod{n}$. От това следва:
  \begin{equation}
    m^{ed} \equiv m^{e^d} \equiv m \pmod{n}
    \label{rsa-key-cancelation}
  \end{equation}
  Използвайки това тъждество, $e$ и $n$ формират публичният ключ, а $d$ и $n$ формират тайният ключ. Нужен е само метод за генериране на числото $d$, който да зависи от тайна информация, така че само един човек да може да го изпълни.

  Вторият факт е че разлагането на едно съставно число на простите му съставки е бавна операция, но умножаването на две прости числа за да се получи съставно число е бърза операция. Т.е. ако бъдат генерирани две големи прости числа $p$ и $q$ и бъдат умножени заедно се получава число, което може да бъде разложено бързо само от този, който вече знае кои са числата $p$ и $q$.

  Това е полезно в комбинация с третия факт, който е една от теоремите на Ойлер:
  \begin{equation}
    a^{\phi(n)} \equiv 1 \pmod{n}
    \label{rsa-euler-theorem}
  \end{equation}
  Където $\phi(n)$ е функцията на Ойлер, която за всяко число $n$ връща броя на естествените числа от 1 до $n$ които са взаимно прости с $n$. Примери:
  \begin{equation}
    \begin{split}
      \phi(7) &= 6 (1,2,3,4,5,6) \\
      \phi(8) &= 4 (1,3,5,7) \\
      \phi(9) &= 6 (1,2,4,5,7,8) \\
    \end{split}
    \label{rsa-euler-function}
  \end{equation}
  В общия случай за случайно число $n$ е трудно да се пресметне $\phi(n)$, но ако $p$ и $q$ са две различни прости числа то се знае следното:
  \begin{equation}
    \begin{split}
      \phi(p) &= p-1 \\
      \phi(q) &= q-1 \\
      \phi(pq) &= \phi(p)\phi(q) \\
      &= (p-1)(q-1) \\
    \end{split}
    \label{rsa-phi-calculation}
  \end{equation}
  Следователно $\phi(n)$ е функция, която е лесна да се пресметне само ако се знае как се разлага числото $n$.

  Ако бъдат комбинирани тези уравнения по начинът, описан в уравнения \ref{rsa-culmination}, ще се получи метод за генериране на $d$ който е лесен за изпълняване само ако се знае как се разлага $n$ (понеже за да се изчисли $d$ е нужно да се изчисли $\phi(n)$).
  \begin{equation}
    \begin{alignedat}{2}
      m^{\phi(n)} &\equiv 1 &\pmod n \\
      m^{k\phi(n)} &\equiv 1^k &\pmod n \\
      m^{k\phi(n)} &\equiv 1 &\pmod n \\
      m\times m^{k\phi(n)} &\equiv m\times 1 &\pmod n \\
      m^{k\phi(n)+1} &\equiv m &\pmod n \\
      m^{e\frac{k\phi(n)+1}{e}} &\equiv m &\pmod n \\
      m^{ed} &\equiv m &\pmod n\\
      d &= \frac{k\phi(n)+1}{e} \\
    \end{alignedat}
    \label{rsa-culmination}
  \end{equation}
  Следователно RSA алгоритъмът обобщено изглежда така:
  \begin{enumerate}
    \item Генерират се две големи прости числа $p$ и $q$.
    \item Намира се $n$ по формулата $n = p \times q$.
    \item Избират се стойности за $k$ и $e$ и се изчислява $d$ чрез формулата: $$d = \frac{k(p-1)(q-1)+1}{e}$$
    \item Публично се публикуват числата $n$ и $e$, докато $d$, $p$ и $q$ остават тайни.
  \end{enumerate}

  Остават още няколко детайла за изясняване, един от които е как се генерират големите прости числа $p$ и $q$ бързо. Това е обяснено в точка \ref{primesalgo}. Другите детайли са как се избират $e$ и $k$.

  Числото $e$ се избира така че $e$ и $\phi(n)$ да са взаимно прости. % FIXME - why?
  Най-често за $e$ се използва стойността 65537 ($2^{16}+1$). % FIXME - why???

  Числото $k$ се избира така, че $d$ да се получи цяло число. За тази цел се използва разширеният алгоритъм на Евклид, който за две дадени числа $a$ и $b$ намира числа $\gcd(a,b)$ (най-голямото общо кратно на $a$ и $b$), $x$ и $y$ така, че тъждеството на Безу (тъждество \ref{rsa-bezout}) да е вярно:
  \begin{equation}
    ax+by = \gcd(a,b)
    \label{rsa-bezout}
  \end{equation}
  Ако в тъждество \ref{rsa-bezout} се замести $a=\phi(n)$ и $b=e$ то стойността на $k$ се получава че е $e-x$ чрез следните разсъждения:
  \begin{equation}
    \begin{alignedat}{1}
      d = \frac{ka+1}{b} \\
      ka + 1 &\equiv 0 \pmod{b} \\
      ka + \gcd(a,b) &\equiv 0 \pmod{b} \\
      ka + ax + by &\equiv 0 \pmod{b} \\
      ka + ax &\equiv 0 \pmod{b} \\
      a(k+x) &\equiv 0 \pmod{b} \\
      a(b-x+x) &\equiv 0 \pmod{b} \\
      k = b - x \\
    \end{alignedat}
    \label{rsa-finding-k}
  \end{equation}
  Но има и други стойности, които биха проработили като стойности за $k$ (напр. $2e-x$).

  \subsection{Алгоритъм за бързо намиране на големи прости числа използвайки малката теорема на Ферма} \label{primesalgo}
  Алгоритмите за намиране на прости числа като решетото на Ератостен\cite{primesieve} намират всички прости числа между 1 и някаква горна граница $N$, но ако $N$ е голямо това е бавен процес. Но за целта на RSA не е нужен голям брой прости числа, а само две, много големи прости числа. Също така на практика не е нужно числата, които биват генерирани, да са доказуемо прости, стига шансът да не са прости да е много, много малък.

  Алгоритъмът, който се използва се базира на малката теорема на Ферма, която гласи, че за всяко цяло число $a$ и всяко просто число $p$ важи следното тъждество:
  \begin{equation}
    a^p \equiv a \pmod{p}
    \label{fermat}
  \end{equation}
  Но в случай, че не се знае дали $p$ е просто, тъждеството може да бъде използвано като метод за проверка. При избирането на различни стойности за $a$ ако бъде намерена стойност, при която тъждеството не важи, то със сигурност $p$ не е просто число. Но ако след десетки опити не бъде открито такава стойност за $a$, то има голям шанс $p$ да е просто.
  Съществуват съставни числа $p$, за които тъждеството \ref{fermat} важи за всяка стойност на $a$, въпреки че не са прости. Това са числата на Кармайкъл и са сравнително редки.\cite{carmichaelrare} % FIXME - second primality check

  \subsection{Превръщане на съобщение в число и обратно} \label{paddingscheme}
  RSA работи върху числа, но съобщенията, които най-често се изпращат, са данни. За щастие тези данни могат да се представят като байтове, а всеки байт реално представлява число. Няколко байта един до друг представляват по-голямо число, но не може да бъде изпратено едно дълго съобщение като едно число, защото поради начина на работа на RSA декриптираното число винаги ще бъде между $0$ и $N-1$, следователно оригиналното число трябва да е по-малко от $N$ за да няма загуба на информация. Това се постига лесно като се раздели съобщението на няколко части и се криптират/декриптират отделно. Това разделяне, обаче, трябва да се направи внимателно. Ако всяко парче просто бъде криптирано и изпратено, то две еднакви парчета ще се криптират по един и същи начин. Проблемът става по-очевиден при размер на парчетата равен на една буква. Решението е просто - добавяне на случайни байтове към началото или края на всяко парче, които да бъдат игнорирани от получателя. Количеството байтове трябва да е по-голямо за по-дълги съобщения за да се минимизира шансът от повторения.

  \subsection{Алгоритъм за бързо експониране на големи числа (бинарно експониране)} \label{binexp}
  Най-простият алгоритъм за изчисляване на $a^b$ е да се умножи $a$ по себе си $b$ брой пъти. Този алгоритъм отнема $\mathcal{O}(b)$ умножения, което го прави непоносимо бавен за големи стойности на $b$. Бинарното експониране е по-бърз алгоритъм, който отнема само $\mathcal{O}(\log b)$ умножения.
  Първото, което трябва да се забележи, е следното:
  \begin{equation}
    a^x \times a^y = a^{x + y}
    \label{exp-breakability}
  \end{equation}
  От това следва, че всяка степен $b$ може да се представи като различни степени на двойката, които после да бъдат събрани заедно в един общ резултат. Пример за това е даден в уравнение \ref{exp-breakability-example}:
  \begin{equation}
    a^{13} = a^8 \times a^4 \times a^1
    \label{exp-breakability-example}
  \end{equation}
  Това само по себе си не помага, защото ако изчисляването на $a^{16}$ отнема 15 умножения, то финалният брой умножения остава същия. Но има по-бърз метод, който бива демонстриран в уравнение \ref{exp-squaring-example}. Ключото наблюдение, което трябва да бъде направено, е че $a^8$ трябва да се изчисли само веднъж:
  \begin{equation}
    a^{16} = a^8 \times a^8
    \label{exp-squaring-example}
  \end{equation}
  Ако $a^8$ отнема 7 умножения, то $a^{16}$ ще отнеме 8. Но реално съшият метод може да се приложи и за $a^8$, $a^4$ и т.н. В общия случай важи следното (като подвигането на квадрат изисква само едно умножение):
  \begin{equation}
    a^{2^x} = (a^{2^{x-1}})^2
    \label{exp-squaring}
  \end{equation}
  Ако тъждеството \ref{exp-squaring} се повтори до достигането на $a^1$ ($a^{2^0}$) се получават точно $x$ (или $\log_2 2^x$) повдигания на квадрат. Това прави финалният алгоритъм за какъвто и да било експонент $b$ да отнема най-много $2 \times \lfloor \log_2 b \rfloor$ умножения, което е еквивалентно на $\mathcal{O}(\log b)$

  Фигура \ref{fig:binexp} показва примерна имплементация на алгоритъма, описан горе. Тази имплементация не може да се използва за RSA криптиране, защото тъй като $e$ е голямо число, то резултата от експонирането ще бъде твърде голям, за да се побере в паметта. За щастие при RSA не се изисква целия резултат, а само остатъка при деление на $n$. Фигура \ref{fig:binmodexp} показва модифицирания алгоритъм, където {\tt a\%b} означава остатъка при извършването на делението $\frac{a}{b}$. Тази модификация се възползва от няколко свойства на модуларната аритметика:
  \begin{equation}
    \begin{alignedat}{3}
      \textrm{Ако } x &\equiv y &\pmod{n}  \\
      \textrm{и } a &\equiv b &\pmod{n} \\
      \hline
      x + a &\equiv b + y &\pmod{n} \\
      x \times a &\equiv b \times y &\pmod{n} \\
      x^k &\equiv y^k &\pmod{n}&, \forall k. \\
    \end{alignedat}
    \label{modular-arithmetic-properties}
  \end{equation}
  Тези свойства позволяват междинните резултати на всяка стъпка да се редуцират по дължина и по този начин се гарантира, че винаги ще могат да се поберат в паметта.

  \begin{figure}[htpb]
    \caption{Примерна имплементация на $b^e$ чрез бинарно експониране}
    \label{fig:binexp}
    \begin{minted}{C}
    int exponentiation(int b, int e) {
      int res = 1;
      while (e != 0) {
        if (e & 1) {
          res *= b;
        }
        b *= b;
        e = e >> 1;
      }
      return res;
    }
    \end{minted}
  \end{figure}

  \begin{figure}[htpb]
    \caption{Примерна имплементация на {\tt $b^e$ \% m} чрез бинарно експониране}
    \label{fig:binmodexp}
    \begin{minted}{C}
    int exponentiation(int b, int e, int m) {
      b = b % m;
      int res = 1;
      while (e != 0) {
        if (e & 1) {
          res *= b;
          res = res % m;
        }
        b *= b;
        b = b % m;
        e = e >> 1;
      }
      return res;
    }
    \end{minted}
  \end{figure}

  \subsection{Алгоритъм за бързо умножение на големи числа (алгоритъма на Карацуба)} \label{karatsuba}
  Обикновеният алгоритъм за умножение изисква $\mathcal{O}(n^2)$ стъпки (умножения на две цифри заедно) където $n$ е броят цифри в двете числа. Алгоритъмът на Карацуба е рекурсивен метод за умножение, който изисква само $\mathcal{O}(n^{\log_2 3}) \approx \mathcal{O}(n^{1.58})$ стъпки.

  Ако са дадени числата $x$ и $y$ и се търси $x \times y$ то първото, което може да се направи, е да представим двете дадени числа по следният начин:
  \begin{equation}
    x = x_1 B + x_0
    y = y_1 B + y_0
    \label{karatsuba-breakability}
  \end{equation}
  Където $B$ е степен на основата, в която са представени в числата (ако са представени в бинарната система то $B$ ще бъде степен на двойката, като степента се избира така, че двете нови числа да бъдат приблизително равни по дължина). От това следва че $x \times y$ може да се представи като:
  \begin{equation}
    \begin{split}
      x \times y &= (x_1 B + x_0) \times (y_1 B + y_0) \\
                 &= z_2 B^2 + z_1 B + z_0 \\
    \end{split}
    \label{karatsuba-quadratic}
  \end{equation}
  където
  \begin{equation}
    \begin{split}
      z_0 &= x_0 y_0 \\
      z_1 &= x_1 y_0 + x_0 y_1 \\
      z_2 &= x_1 y_1 \\
    \end{split}
    \label{karatsuba-three-unknowns}
  \end{equation}
  Тези формули (\ref{karatsuba-quadratic} и \ref{karatsuba-three-unknowns}) изискват 4 по-малки умножения (умножаването по $B$ се свежда до добавяне на нули след числото и за това не се брои) и следователно ако тези умножения бъдат извършени рекурсивно със същия алгоритъм то финалният алгоритъм все още ще отнема $\mathcal{O}(n^2)$ стъпки.

  Оптимизацията идва от факта, че $z_1$ може да се изчисли с едно умножение по-малко като се използват стойностите на $z_0$ и $z_2$:
  \begin{equation}
    z_1 = (x_1 + x_0)(y_1 + y_0) - z_2 - z_0
    \label{karatsuba-trick}
  \end{equation}

  Ако броят стъпки се означи с $f(n)$ където $n$ е дължината на входните числа, то следва:
  \begin{equation}
    f(n) = 3f(n/2) + \mathcal{O}(n)
    \label{karatsuba-complexity-equation}
  \end{equation}
  След използването на основната теорема за решаване на рекурентни зависимости\cite[глава~4.5]{algo-intro} (``master theorem'' на английски) върху уравнение \ref{karatsuba-complexity-equation} се получава, че $f(n) = \mathcal{O}(n^{log_2 3})$ и с това приключва описанието на алгоритъма. В базовия случай, когато числата станат достатъчно малки, се използва вграденото в процесора умножение или обикновения алгоритъм за умножение.


