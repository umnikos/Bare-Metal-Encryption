% software description (8-10 pages)
\chapter{Втора глава} % FIXME
\section{Функционални изисквания към bare-metal приложение за асиметрично криптиране}
Приложението трябва да:
\begin{itemize}
  \item бъде bare-metal
  \item криптира/декриптира данни
  \item с асиметрично криптиране
  \item изпратени и получени по сериина връзка
  \item приложението трябва да имплементира сериината връзка
  \item сериината връзка трябва да е virtio-serial връзка
\end{itemize}

\section{Избор на език за програмиране и компилатор}
За разработката на bare-metal приложение за x86 архитектура е задължително да се използва, поне от части, асемблер. Асемблатора, използван в проекта, е {\tt NASM}. Но разработването на целия проект само с асемблер би било бавно и трудно и за това е използван и език от по-високо ниво.

Малко езици от високо ниво са подходящи за разработване на bare-metal приложение. Езиците, които ще бъдат разгледани тук са {\tt C} и {\tt Zig}.

{\tt C} е език с дълга история и е един от най-популярните и най-широко разпространените езици от високо ниво за писане на код от ниско ниво. Позволява лесно да се интегрира с асемблер чрез своето широко поддържано и лесно за използване {\tt System V ABI}\parencite{sysvabi} и като цяло е добър избор за какъвто и да било проект. Ядрото на Linux операционната система е почти изцяло написано на {\tt C}.

{\tt Zig} е (по време на писането на този документ) доста нов език, който се цели да замени {\tt C} и да предостави нови удобства за програмиста\parencite{whyzig}. Най-големият му проблем идва именно от това, че е нов - документацията му е оскъдна и няма написани книги от където да бъде научен в детайли. Именно заради това не беше избран за този проект, а вместо него беше избран езикът {\tt C}.

Под въпрос е и как ще бъде компилиран кодът. Компилаторът трябва да знае, че компилираният машинен код няма да върви върху операционна система и няма да има достъп до {\tt libc} - стандартната {\tt C} библиотека. Един от възможните начини е да се използва стандартен {\tt C} компилатор и да му се подадат купчина флагове, които да му казват точно това. Друг начин е да се направи cross-compiler (компилатор от една среда към друга). Трети е да се използва {\tt Zig} компилатора като {\tt C} компилатор със следната команда:
{\tt zig cc -target i386-freestanding}.
Най-голям успех бе постигнат с втория метод, въпреки че е и най-трудоемкия.

\section{Избор на алгоритъм за асиметрично криптиране} % should this be a thing?
\section{Избор на библиотеки и други средства}
\section{Описание на използваните алгоритми}
  % INCLUDE PICTURES
  \subsection{Обяснение на RSA алгоритъма}
  \subsection{Алгоритъм за бързо намиране на големи прости числа използвайки малката теорема на Ферма}
  \subsection{Превръщане на съобщение в число и обратно}
  \subsection{Алгоритъм за бързо експониране на големи числа (бинарно експониране}
  \subsection{Алгоритъм за бързо умножение на големи числа (алгоритъма на Карацуба}

