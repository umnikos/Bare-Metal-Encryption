% software description (8-10 pages)
\section{Избор на средства}
\subsection{Изисквания}
% RSA on bare metal
Поставените изисквания: \textit{Приложението трябва да криптира/декриптира данни с асиметрично криптиране изпратени по virtio-serial връзка до него и да връща резултата по същата връзка. Приложението трябва да имплементира virtio-serial връзката.}

Избрах да имплементирам RSA криптиране защото е популярен, стар и не толкова сложен алгоритъм за асиметрично криптиране и следователно е добре описан в интернет.

\subsection{Избор на език за програмиране и библиотеки} \label{langchoice}
% C, tiny-bignum-c, GRUB, QEMU
% Rust or Zig may have been better but I only know C
За програмиране от най-ниско ниво е задължително използването на асемблер\footnote{Използвах {\tt nasm} за асемблирането защото съм най-запознат с него.}. Но само асемблер е неудобно за ползване, за това съм използвал и {\tt C}. {\tt C} е най-популярният и един от най-добрите езици за писане на код от ниско ниво и следователно беше доста добър избор за проекта. {\tt Zig} може би щеше да бъде по-добър избор но не съм запознат с него и поради новостта му няма голям брой източници от които да го науча.

Използвам чужд буутлоъдър защото няма смисъл да създавам мой и това е извън рамките на изискванията. Буутлоъдъра който избрах е GRUB.

За реализацията на криптирането трябват числа по-големи от 32/64 бита, а {\tt C} не идва с такива и за това се нуждаех от библиотека за големи числа. Повечето библиотеки обаче използват функии от libc, които моето ядро не имплементира. Библиотеката на която се спрях е ``tiny-bignum-c''\parencite{tinybignumc} защото е малка ($\sim500$ реда код), open-source, с отворен лиценз\footnote{Това ми позволява да създам мое копие на софтуера и да го променям както пожелая} (Unlicense) и не ползва нищо от libc (включително и {\tt malloc}).

\subsection{Описание на алгоритмите}
Ако не разбирате някой термин, потърсете го в глава \ref{research} - \nameref{research}
\subsubsection{Първи задачи на ядрото}
Първото нещо което правим е да създадем стек за да можем да организираме кодът ни като функции и да можем да пишем на {\tt C}. След това изключваме прекъсванията и създаваме GDT и IDT таблици. GDT таблицата я пълним с два реда\footnote{Плюс трети, нулев ред, който е задължителен но не прави нищо}, които казват че имаме достъп да пишем, четем и изпълняваме цялата памет. IDT таблицата я пълним с адресите на две функции които не правят нищо освен да сложат край на прекъсването. Тях можем после да ги заменим с адресите на функции, които правят нещо при прекъсване. След това включваме прекъсванията и викаме главната функция, която стартира апликацията ни.

\subsubsection{RSA криптиране в детайли} \label{rsaalgo}
% math & formulas
Използват се няколко математически трика. Първият е че модулното експониране е еднопосочна функция. Т.е. ако знаем стойностите на $m$, $e$ и $n$ е много по-лесно да изчислим $m^e \equiv x \pmod n$ отколкото $x^e \equiv m \pmod n$. Това ни позволява да използваме тази операция за криптиране на съобщение, но ни трябва и метод за декриптиране. Нека $d$ е число така че ако $m^e \equiv x \pmod n$ то $x^d \equiv m \pmod n$. От това следва че:
$$m^{ed} \equiv m^{e^d} \equiv m \pmod n$$
$e$ и $n$ са публичният ключ, а $d$ и $n$ са тайният ключ. Нуждаем се само от начин за генериране на числото $d$ който само ние можем да изпълним.

Вторият трик е че разлагането на едно композитно число на простите му съставки е бавна операция, но умножаването на две прости числа за да получим композитно число е бърза операция. Т.е. ако генерираме две големи прости числа $p$ и $q$ и ги умножим, получаваме число чиито прости съставки само ние знаем.

Това е полезно в комбинация с третият трик, и той е една от теоремите на Ойлер:
$$a^{\phi(n)} \equiv 1 \pmod n$$
Където $\phi(n)$ е функцията на Ойлер, която за всяко число $n$ връща броя на естествените числа от 1 до $n$ които за взаимно прости с $n$. Примери:
\begin{equation*}
\begin{split}
\phi(7) &= 6 \\
\phi(8) &= 4 \\
\phi(9) &= 6 \\
\end{split}
\end{equation*}
В общият случай за случайно число $n$ е трудно да се пресметне стойността на тази функция, но ако $p$ и $q$ са две различни прости числа то знаем че:
\begin{equation*}
\begin{split}
\phi(p) &= p-1 \\
\phi(q) &= q-1 \\
\phi(pq) &= \phi(p)\phi(q) \\
&= (p-1)(q-1) \\
\end{split}
\end{equation*}
Следователно $\phi(n)$ е функция която е лесна да се пресметне само ако знаем как се разлага числото $n$. Ако се върнем в теоремата на Ойлер и направим няколко трансформации ще получим\ldots
\begin{alignat*}{2}
m^{\phi(n)} &\equiv 1 &\pmod n \\
m^{k\phi(n)} &\equiv 1^k &\pmod n \\
m^{k\phi(n)} &\equiv 1 &\pmod n \\
m\times m^{k\phi(n)} &\equiv m\times 1 &\pmod n \\
m^{k\phi(n)+1} &\equiv m &\pmod n \\
m^{e\frac{k\phi(n)+1}{e}} &\equiv m &\pmod n \\
m^{ed} &\equiv m &\pmod n\\
d &= \frac{k\phi(n)+1}{e} \\
\end{alignat*}
Където $k$ е каквото и да било число, като го избираме така че да получим целочислен резултат за $d$. За изчисляването на $d$ е нужно да се изчисли $\phi(n)$, което става бързо само ако са известни простите множители на $n$. Следователно ако генерираме две тайни прости числа $p$ и $q$ и използваме $p\times q$ за $n$ то само ние ще можем да пресметнем $d$.

Остават още няколко детайла за изясняване, един от които е как се изчисляват големи прости числа бързо. На този въпрос е отговорено в част \ref{fermatprimes}. Другите детайли са как избираме $e$ и $k$.

Избираме $e$ така че $\gcd(\phi(n), e) = 1$, където $\gcd(a,b)$ е най-голямото общо кратно на $a$ и $b$. Най-често за $e$ се използва стойността 65537. $k$ изчисляваме като използваме разширеният алгоритъм на Евклид, който за две дадени цели числа $a$ и $b$ намира две цели числа $x$ и $y$ така че следното уравнение да е вярно: (т.нар. тъждество на Безу)
$$ ax + by = \gcd(a,b) $$
Ако $a = \phi(n)$ и $b = e$ то следва че:
\begin{alignat*}{2}
d = \frac{ka+1}{b} \\
ka + 1 &\equiv 0 &\pmod b \\
ka + \gcd(a,b) &\equiv 0 &\pmod b \\
ka + ax + by &\equiv 0 &\pmod b \\
ka + ax &\equiv 0 &\pmod b \\
a(k+x) &\equiv 0 &\pmod b \\
a(b-x+x) &\equiv 0 &\pmod b \\
k = b-x \\
\end{alignat*}
Разширеният алгоритъм на Евклид намира $x$ и $y$ така че $|x|\leq|b/\gcd(a,b)|$ и $|y|\leq|a/\gcd(a,b)|$. Равенство може да се получи само ако $\gcd(a,b)=a$ или $\gcd(a,b)=b$, но понеже в нашият случай $\gcd(a,b)=1\neq a\neq b$ следва че $|x|<|b|$, и тъй като $b>0$ е гарантирано $b-x$ да e положително цяло число.

\subsubsection{Алгоритъм за намиране на големи прости числа} \label{fermatprimes}
Обикновените алгоритми за намиране на прости числа (като напр. решетото на Ератостен) намират всички прости числа между 1 и $N$, но на нас не ни трябват всички прости числа, а само едно. Също така не е нужно да сме на 100\% сигурни че числото е просто, защото 99.999999999\% сигурност е достатъчно добре на практика.

Алгоритъмът който се използва се базира на малката теорема на Ферма, която казва че за всяко цяло число $a$ и всяко просто число $p$ важи следното:
$$ a^p \equiv a \pmod p $$
Но в случай че не знаем дали $p$ е просто, можем да използваме същата теорема за да проверим като изпробваме различни стойности на $a$. Ако намерим стойност за $a$ където теоремата не е вярна то знаем че $p$ не е просто, но ако след десетки опити не открием такова число, можем да сме сравнително убедени в простотата на числото $p$.

Изключение от това правило са числата на Кармайкъл. Това са всички композитни числа за които теоремата на Ферма все пак важи за всяко цяло число $a$. Те са рядкост но могат да се премахнат чрез използването на още един, различен тест за тестване на простотата на числото $p$.

\subsubsection{Алгоритъм за бързо експониране на големи числа}
Наивният алгоритъм за изчисляване на $a^b$ е да умножим $a$ по себе си $b$ пъти, но това е $\mathcal{O}(b)$ алгоритъм и за големи стойности на $b$ става непоносимо бавен. За това използвам бинарно експониране което е $\mathcal{O}(\log b)$ алгоритъм за постигане на същата цел.

Първото което трябва да забележим е че:
$$ x^y \times x^z = x^{y+z} $$
Следователно всяка степен $b$ можем да я разчупим на множество степени на двойката които после да съберем заедно. Пример:
$$ a^{13} = a^8 \times a^4 \times a^1 $$
Това ни помага защото изчисляването на $a^{(2^x)}$ е лесно и отнема $\mathcal{O}(x)$ време:
$$ a^{(2^x)} = (a^{(2^{x-1})})^2$$
Тъй като повдигането на квадрат се постига лесно чрез умножаване на числото по себе си.

Финалният алгоритъм изглежда по следния начин:
\begin{lstlisting}[language=C]
void exponentiation(ii* b_in, ii* e_in, ii* res) {
  inii(b); // b = b_in
  inii(e); // e = e_in

  mkii(temp); // ii temp
  ii one; bignum_from_int(&one, 1);

  bignum_from_int(res, 1); // res = 1
  while (!bignum_is_zero(e)) { // while (e != 0) {
    if (e->array[0]&1) { // if (e & 1) {
      // res *= b
      bignum_mul(res, b, temp);
      bignum_assign(res, temp);
    }
    // b *= b
    bignum_mul(b, b, temp);
    bignum_assign(b, temp);
    // e = e >> 1
    bignum_rshift(e, temp, 1);
    bignum_assign(e, temp);
  }
}
\end{lstlisting}
