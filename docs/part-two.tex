% software description (8-10 pages)
\chapter{Втора глава} % FIXME
\section{Функционални изисквания към bare-metal приложение за асиметрично криптиране}
Приложението трябва да:
\begin{itemize}
  \item бъде bare-metal
  \item криптира/декриптира данни
  \item с асиметрично криптиране
  \item изпратени и получени по сериина връзка
  \item приложението трябва да имплементира сериината връзка
  \item сериината връзка трябва да е virtio-serial връзка
\end{itemize}

\section{Избор на език за програмиране и компилатор}
За разработката на bare-metal приложение за x86 архитектура е задължително да се използва, поне от части, асемблер. Асемблатора, използван в проекта, е {\tt NASM}. Но разработването на целия проект само с асемблер би било бавно и трудно и за това е използван и език от по-високо ниво.

Малко езици от високо ниво са подходящи за разработване на bare-metal приложение. Езиците, които ще бъдат разгледани тук са {\tt C} и {\tt Zig}.

{\tt C} е език с дълга история и е един от най-популярните и най-широко разпространените езици от високо ниво за писане на код от ниско ниво. Позволява лесно да се интегрира с асемблер чрез своето широко поддържано и лесно за използване {\tt System V ABI}\parencite{sysvabi} и като цяло е добър избор за какъвто и да било проект. Ядрото на Linux операционната система е почти изцяло написано на {\tt C}.

{\tt Zig} е (по време на писането на този документ) доста нов език, който се цели да замени {\tt C} и да предостави нови удобства за програмиста\parencite{whyzig}. Най-големият му проблем идва именно от това, че е нов - документацията му е оскъдна и няма написани книги от където да бъде научен в детайли. Именно заради това не беше избран за този проект, а вместо него беше избран езикът {\tt C}.

Под въпрос е и как ще бъде компилиран кодът. Компилаторът трябва да знае, че компилираният машинен код няма да върви върху операционна система и няма да има достъп до {\tt libc} - стандартната {\tt C} библиотека. Един от възможните начини е да се използва стандартен {\tt C} компилатор и да му се подадат купчина флагове, които да му казват точно това. Друг начин е да се направи cross-compiler (компилатор от една среда към друга). Трети е да се използва {\tt Zig} компилатора като {\tt C} компилатор със следната команда:
{\tt zig cc -target i386-freestanding}.
Най-голям успех бе постигнат с втория метод, въпреки че е и най-трудоемкия.

\section{Избор на алгоритъм за асиметрично криптиране} % should this be a thing?

\section{Избор на библиотеки и други средства}

\section{Описание на използваните алгоритми}
  % INCLUDE PICTURES
  \subsection{Обяснение на RSA алгоритъма}

  \subsection{Алгоритъм за бързо намиране на големи прости числа използвайки малката теорема на Ферма}

  \subsection{Превръщане на съобщение в число и обратно}

  \subsection{Алгоритъм за бързо експониране на големи числа (бинарно експониране)}

\begin{figure}[p]
\caption{Имплементация на бинарно експониране}
\begin{lstlisting}[language=C]
void exponentiation(ii* b_in, ii* e_in, ii* res) {
  inii(b); // b = b_in
  inii(e); // e = e_in

  mkii(temp); // ii temp
  ii one; bignum_from_int(&one, 1);

  bignum_from_int(res, 1); // res = 1
  while (!bignum_is_zero(e)) { // while (e != 0) {
    if (e->array[0]&1) { // if (e & 1) {
      // res *= b
      bignum_mul(res, b, temp);
      bignum_assign(res, temp);
    }
    // b *= b
    bignum_mul(b, b, temp);
    bignum_assign(b, temp);
    // e = e >> 1
    bignum_rshift(e, temp, 1);
    bignum_assign(e, temp);
  }
}
\end{lstlisting}
\end{figure}

  \subsection{Алгоритъм за бързо умножение на големи числа (алгоритъма на Карацуба)} \label{karatsuba}

